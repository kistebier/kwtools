#!/bin/zsh
#
# Autor: Kai Wilke <kiste@netzworkk.de> 27.11.2016
#
# Script: kwnarc, Firewall mittels iptables starten.
# KWNARC - kwtools Netfilter Automatic Rule Configurator
# once
# NARC - Netfilter Automatic Rule Configurator v0.7
# Copyright (c) 2001, Shane Chen (shane@knowplace.org).
#
# Version: 0.1.2
#
setopt extendedglob

PATH=/bin:/sbin:/usr/bin:/usr/sbin

# ZSH colors-Modul laden und ausführen
autoload -U colors && colors

# checken der Konfigurationsdatei.
if [ -f /etc/kwtools/kwnarc/kwnarc.conf ] ; then
	MAIN_CONF=/etc/kwtools/main.cf
	CONF_DIR=/etc/kwtools/kwnarc
	CONFIG="${CONF_DIR}/kwnarc.conf"
elif [ -f /usr/local/etc/kwtools/kwnarc/kwnarc.conf ] ; then
	MAIN_CONF=/usr/local/etc/kwtools/main.cf
	CONF_DIR=/usr/local/etc/kwtools/kwnarc
	CONFIG="${CONF_DIR}/kwnarc.conf"
else
	CONFIG=""
fi

# Error messages
#alias echo='echo -n'
OK="OK"
FAIL="FAILED"
CONF_ERR="Please check the $CONFIG for errors!"
ABORT="KWNARC start aborted!"

# Check terminal
if [ "$TERM" != "raw" -a -f "$MAIN_CONF" ] ; then
	. $MAIN_CONF
	RCOK="${B_GREEN}${OK}${NORMAL}"
	RCFAIL="${B_RED}${FAIL}${NORMAL}"
	RCCONF_ERR="Please check the ${B_WHITE}${CONFIG}${NORMAL} for errors!"
	RCABORT="${RED}${ABORT}${NORMAL}"
else
	RCOK="$OK"
	RCFAIL="$FAIL"
	RCCONF_ERR="$CONF_ERR"
	RCABORT="$ABORT"
fi

# temp file remove function# {{{
removetemp()
{
	if test -f ${TMPDIR}/kwnarc.tmp ; then
		rm ${TMPDIR}/kwnarc.tmp
	fi
}
## }}}
# Configurations Error exit functions# {{{
confexit()
{
	echo $RCCONF_ERR
	removetemp
	exit 1
}
## }}}
# Abort exit functions# {{{
abortexit()
{
	echo $RCABORT
	echo "Something bad happened!"
	removetemp
	exit 1
}
## }}}

# temp directory detection
if test -d /var/tmp ; then
	TMPDIR="/var/tmp"
else
	if test -d /tmp ; then
		TMPDIR="/tmp"
	fi
fi

# Load kwnarc Configuration file
if [ ! -z "$CONFIG" ] ; then
	. $CONFIG
else
	echo $RED"KWNARC error:$NORMAL Cannot find $CONFIG! Aborting." || exit 1
	abortexit
fi

KERNVER=$(uname -r)
# Check for the iptables binary
IPTABLES="${commands[iptables]}"
IP6TABLES="${commands[ip6tables]}"
if [[ ! -x $IPTABLES ]] ; then
	echo $RED"Conf error:$NORMAL ${B_WHITE}${IPTABLES}${NORMAL} executable missing."
	confexit
fi
if [[ ! -x $IP6TABLES ]] ; then
	echo $RED"Conf error:$NORMAL ${B_WHITE}${IP6TABLES}${NORMAL} executable missing."
	confexit
fi

##
## Command usage section
##
# Check commandline usage
case "$1" in
	start)
		echo
		echo $B_WHITE"kwnarc$NORMAL (kwtools Netfilter Automatic Rule Configurator)"
		echo "Starting ip(6)tables and creating all chains"
		;;
	status)
		echo $B_WHITE"kwnarc$NORMAL (kwtools Netfilter Automatic Rule Configurator)"
		echo "Displaying IPv4 active rules"
		$IPTABLES -L --line -nv || abortexit
		echo ""
		echo "Displaying IPv6 active rules"
		$IP6TABLES -L --line -nv || abortexit
		echo ""
		exit 0
		;;
	conntrack)
		echo $B_WHITE"kwnarc$NORMAL (kwtools Netfilter Automatic Rule Configurator)"
		if [[ -r /proc/net/ip_conntrack ]] ; then
			echo "Displaying current connection tracking info:"
			cat /proc/net/ip_conntrack
		else
			echo "No connection tracking info"
		fi
		exit 0
		;;
	stop)
		echo
		echo $B_WHITE"kwnarc$NORMAL (kwtools Netfilter Automatic Rule Configurator)"
		echo "Stopping ip(6)tables and deleting all chains"
		# Ipv4
		$IPTABLES -F || abortexit
		$IPTABLES -X || abortexit
		$IPTABLES -F -t nat || abortexit
		$IPTABLES -X -t nat || abortexit
		$IPTABLES -F -t mangle || abortexit
		$IPTABLES -X -t mangle || abortexit
		$IPTABLES -P INPUT ACCEPT || abortexit
		$IPTABLES -P FORWARD ACCEPT || abortexit
		$IPTABLES -P OUTPUT ACCEPT || abortexit
		# Ipv6
		$IP6TABLES -F || abortexit
		$IP6TABLES -X || abortexit
		$IP6TABLES -F -t nat || abortexit
		$IP6TABLES -X -t nat || abortexit
		$IP6TABLES -F -t mangle || abortexit
		$IP6TABLES -X -t mangle || abortexit
		$IP6TABLES -P INPUT ACCEPT || abortexit
		$IP6TABLES -P FORWARD ACCEPT || abortexit
		$IP6TABLES -P OUTPUT ACCEPT || abortexit
		if [ "$ALWAYS_FORWARD" = 'yes' ] ; then
			if [ "$DYNAMIC_EXTERNAL_IP" = 'no' ] ; then
				# IPv4
				$IPTABLES -t nat -A POSTROUTING -o $EXTERNAL_INTERFACE \
					-j SNAT --to $EXTERNAL_INTERFACE_IP  || abortexit
				# IPv6
				$IP6TABLES -t nat -A POSTROUTING -o $EXTERNAL_INTERFACE \
					-j SNAT --to $EXTERNAL_INTERFACE_IPV6  || abortexit
			else
				# only IPv4
				$IPTABLES -t nat -A POSTROUTING -o $EXTERNAL_INTERFACE \
					-j MASQUERADE || abortexit
			fi
		else
			echo -n "Disabling IPv4 IP forwarding: "
			echo "0" >/proc/sys/net/ipv4/ip_forward && echo $RCOK || echo $RCFAIL
			echo -n "Disabling IPv6 IP forwarding: "
			echo "0" >/proc/sys/net/ipv6/conf/all/forwarding && \
			echo "0" >/proc/sys/net/ipv6/conf/default/forwarding && echo $RCOK || echo $RCFAIL
		fi
		if [[ $TEMP_ADDR == yes ]] ; then
			echo -n "Disabling IPv6 privacy addressing: "
			echo "0" > /proc/sys/net/ipv6/conf/all/use_tempaddr && \
			echo "0" > /proc/sys/net/ipv6/conf/default/use_tempaddr && echo $RCOK || echo $RCFAIL
		fi
		# IPv4
		$IPTABLES -L --line -nv | grep Chain || abortexit
		# IPv6
		$IP6TABLES -L --line -nv | grep Chain || abortexit
		echo $NORMAL"All rules unloaded (yum: cracker box)"
		exit 0
		;;
	chains)
		echo $B_WHITE"kwnarc$NORMAL (kwtools Netfilter Automatic Rule Configurator)"
		echo "Displaying current chains:"
		if [[ -r /proc/net/ip_tables_names ]] ; then
			# IPv4
			while read table ; do
				echo "Displaying current IPv4 chain ${table}:"
				$IPTABLES -t $table -L -n | grep Chain | \
				cut --fields=2 --delimiter='\'
				echo ""
			done < /proc/net/ip_tables_names
			# IPv6
			while read table ; do
				echo "Displaying current IPv6 chain ${table}:"
				$IP6TABLES -t $table -L -n | grep Chain | \
				cut --fields=2 --delimiter='\'
				echo ""
			done < /proc/net/ip_tables_names
		fi
		exit 0
		;;
	* )
		echo $B_WHITE"kwnarc$NORMAL (kwtools Netfilter Automatic Rule Configurator)"
		echo "Usage: $0 {chains|conntrack|start|stop|status}"
		exit 1
		;;
esac

##
## Idiot checks - make sure kwnarc.conf file has been edited properly
##

# Make sure ipchains isn't loaded
removetemp
/sbin/lsmod > $TMPDIR/kwnarc.tmp
if grep ipchains $TMPDIR/kwnarc.tmp &>/dev/null ; then
	echo $B_WHITE"ipchains$NORMAL is loaded. Please disable it before attempting to start iptables"
	abortexit
fi

# Is there an external interface?
if [ "$EXTERNAL_INTERFACE" = '' ] ; then
	echo $RED"Conf error:$NORMAL Missing ${B_WHITE}EXTERNAL_INTERFACE${NORMAL}"
	confexit
fi

# Check/auto-obtain external IP address
# IPv4
if [ "$DYNAMIC_EXTERNAL_IP" = 'no' ] ; then
	if [ "$EXTERNAL_INTERFACE_IP" = '' ] ; then
		echo $RED"Conf error:$NORMAL Missing ${B_WHITE}EXTERNAL_INTERFACE_IP${NORMAL}"
		confexit
	fi
else
	# INFO: Ab kernel Release >=4 zeigt
	# ifconfig die Ethernet Adresse als inet IP an
	# davor war inet addr:IP
	Kernel_Major_Nr=${KERNVER%%.*}
	if [[ $Kernel_Major_Nr -ge 4 ]] ; then
		EXTERNAL_INTERFACE_IP="`print ${${(s, ,)${(M)${(f)"$(export LC_ALL=C ; /sbin/ifconfig $EXTERNAL_INTERFACE)"}##*inet *}}[2]}`"
	else
		EXTERNAL_INTERFACE_IP="`print ${${${(s,:,)${(M)${(f)"$(export LC_ALL=C ; /sbin/ifconfig $EXTERNAL_INTERFACE)"}##*inet addr*}}[2]}%% *}`"
	fi
	if [ "$EXTERNAL_INTERFACE_IP" = '' ] ; then
		echo $RED"KWNARC error:$NORMAL Unable to auto-obtain IP for ${B_WHITE}${EXTERNAL_INTERFACE}${NORMAL}"
		abortexit
	fi
fi
# IPv6
if [ "$EXTERNAL_INTERFACE_IPV6" = '' ] ; then
	echo $RED"Conf error:$NORMAL Missing ${B_WHITE}EXTERNAL_INTERFACE_IPV6${NORMAL}"
	confexit
fi

# Make sure there's an interface to masq to
if [ "$MASQUERADE" = 'yes' ] ; then
	if [[ "$LAN_INTERFACE" == '' && "$DMZ_INTERFACE" == '' ]] ; then
		echo $RED"Conf error:$NORMAL Missing ${B_WHITE}LAN_INTERFACE$NORMAL or ${B_WHITE}DMZ_INTERFACE$NORMAL"
		confexit
	fi
fi

# Make sure the proper interfaces exist
if [[ "$ALLOW_TCP_LAN" != '' && "$LAN_INTERFACE" == '' ]] ; then
	echo $RED"Conf error:$NORMAL ${B_WHITE}ALLOW_TCP_LAN$NORMAL requires ${B_WHITE}LAN_INTERFACE$NORMAL"
	confexit
fi
if [[ "$ALLOW_TCP_LAN_RANGE" != '' && "$LAN_INTERFACE" == '' ]] ; then
	echo $RED"Conf error:$NORMAL ${B_WHITE}ALLOW_TCP_LAN_RANGE$NORMAL requires ${B_WHITE}LAN_INTERFACE$NORMAL"
	confexit
fi
if [[ "$ALLOW_UDP_LAN" != '' && "$LAN_INTERFACE" == '' ]] ; then
	echo $RED"Conf error:$NORMAL ${B_WHITE}ALLOW_UDP_LAN$NORMAL requires ${B_WHITE}LAN_INTERFACE$NORMAL"
	confexit
fi
if [[ "$ALLOW_UDP_LAN_RANGE" != '' && "$LAN_INTERFACE" == '' ]] ; then
	echo $RED"Conf error:$NORMAL ${B_WHITE}ALLOW_UDP_LAN_RANGE$NORMAL requires ${B_WHITE}LAN_INTERFACE$NORMAL"
	confexit
fi
if [[ "$ALLOW_TCP_DMZ" != '' && "$DMZ_INTERFACE" == '' ]] ; then
	echo $RED"Conf error:$NORMAL ${B_WHITE}ALLOW_TCP_DMZ$NORMAL requires ${B_WHITE}DMZ_INTERFACE$NORMAL"
	confexit
fi
if [[ "$ALLOW_TCP_DMZ_RANGE" != '' && "$DMZ_INTERFACE" == '' ]] ; then
	echo $RED"Conf error:$NORMAL ${B_WHITE}ALLOW_TCP_DMZ_RANGE$NORMAL requires ${B_WHITE}DMZ_INTERFACE$NORMAL"
	confexit
fi
if [[ "$ALLOW_UDP_DMZ" != '' && "$DMZ_INTERFACE" == '' ]] ; then
	echo $RED"Conf error:$NORMAL ${B_WHITE}ALLOW_UDP_DMZ$NORMAL requires ${B_WHITE}DMZ_INTERFACE$NORMAL"
	confexit
fi
if [[ "$ALLOW_UDP_DMZ_RANGE" != '' && "$DMZ_INTERFACE" = '' ]] ; then
    echo $RED"Conf error:$NORMAL ${B_WHITE}ALLOW_UDP_DMZ_RANGE$NORMAL requires ${B_WHITE}DMZ_INTERFACE$NORMAL"
    confexit
fi
if [[ "$FORWARD_LAN_TO_DMZ" == 'yes' || "$FORWARD_DMZ_TO_LAN" == 'yes' ]] ; then
	if [[ "$LAN_INTERFACE" = '' || "$DMZ_INTERFACE" = '' ]] ; then
		echo $RED"Conf error:$NORMAL Missing ${B_WHITE}LAN_INTERFACE$NORMAL or ${B_WHITE}DMZ_INTERFACE$NORMAL required for forwarding"
		confexit
	fi
fi
if [ "$PROTECT_FROM_LAN" = 'yes' ] ; then
	if [ "$LAN_INTERFACE" = '' ] ; then
		echo $RED"Conf error: Cannot ${B_WHITE}PROTECT_FROM_LAN$NORMAL without ${B_WHITE}${LAN_INTERFACE}${NORMAL}"
		confexit
	fi
fi
if [ "$PROTECT_FROM_DMZ" = 'yes' ] ; then
	if [ "$DMZ_INTERFACE" = '' ] ; then
		echo $RED"Conf error: Cannot ${B_WHITE}PROTECT_FROM_DMZ$NORMAL without ${B_WHITE}${DMZ_INTERFACE}${NORMAL}"
		confexit
	fi
fi

# Avoid extraneous rules
if [ "$PROTECT_FROM_LAN" = 'no' ] ; then
	if [[ "$ALLOW_TCP_LAN" != '' || "$ALLOW_TCP_LAN_RANGE" != '' || "$ALLOW_UDP_LAN" != '' || "$ALLOW_UDP_LAN_RANGE" != '' ]] ; then
		echo $RED"Conf error:$NORMAL There's no need to explicitly open ports for the LAN if ${B_WHITE}PROTECT_FROM_LAN${NORMAL} is disabled"
		confexit
	fi
fi
if [ "$PROTECT_FROM_DMZ" = 'no' ] ; then
	if [[ "$ALLOW_TCP_DMZ" != '' || "$ALLOW_TCP_DMZ_RANGE" != '' || "$ALLOW_UDP_DMZ" != '' || "$ALLOW_UDP_DMZ_RANGE" != '' ]] ; then
		echo $RED"Conf error:$NORMAL There's no need to explicitly open ports for the DMZ if ${B_WHITE}PROTECT_FROM_DMZ${NORMAL} is disabled"
		confexit
	fi
fi

# Make sure there's something to port foward to if enabled
if [ "$PORT_FORWARD" = 'yes' ] ; then
	if ! test -f $FORWARD_CONF ; then
		echo $RED"Conf error:$NORMAL ${B_WHITE}${FORWARD_CONF}${NORMAL} not found"
		confexit
	fi
	if ! test -f $FORWARD6_CONF ; then
		echo $RED"Conf error:$NORMAL ${B_WHITE}${FORWARD6_CONF}${NORMAL} not found"
		confexit
	fi
	if [[ "$DMZ_INTERFACE" == '' && "$LAN_INTERFACE" == '' ]] ; then
		echo $RED"Conf error:$NORMAL Missing ${B_WHITE}DMZ_INTERFACE$NORMAL or ${B_WHITE}LAN_INTERFACE$NORMAL"
		confexit
	fi
fi

# SYN length module detection
if [ "$CHECK_SYN_PACKET_LENGTH" != 'no' ] ; then
	if [[ ! -f /lib/xtables/libxt_length.so && ! -f /usr/lib/xtables/libxt_length.so \
	&& ! -f /usr/local/lib/xtables/libxt_length.so ]] ; then
		echo $RED"Conf error:$NORMAL ${B_WHITE}CHECK_SYN_PACKET_LENGTH$NORMAL requires CONFIG_NETFILTER_XT_MATCH_LENGTH"
		echo "Missing libxt_length.so"
		confexit
	fi
fi

# limit module detection and config checking
if [ "$ENABLE_LIMIT_RATE" != 'no' ] ; then
	if [[ ! -f /lib/xtables/libxt_limit.so && ! -f /usr/lib/xtables/libxt_limit.so \
	&& ! -f /usr/local/lib/xtables/libxt_limit.so ]] ; then
		echo $RED"Conf error:$NORMAL ${B_WHITE}ENABLE_LIMIT_RATE$NORMAL requires CONFIG_NETFILTER_XT_MATCH_LIMIT"
		echo "Missing libxt_limit.so"
		confexit
	fi
	if [[ "$LIMIT_RATE" == '' || "$LIMIT_BURST" == '' ]] ; then
		echo $RED"Conf error:$NORMAL ${B_WHITE}ENABLE_LIMIT_RATE$NORMAL requires ${B_WHITE}LIMIT_RATE$NORMAL and ${B_WHITE}LIMIT_BURST$NORMAL"
		confexit
	fi
fi

# iplimit module detection
if [[ $ENABLE_IPLIMIT != 'no' ]] ; then
	if [[ -f "/lib/modules/${KERNVER}/kernel/net/netfilter/xt_iprange.ko" || -f "/lib/xtables/libxt_iprange.so" \
	|| -f "/usr/lib/xtables/libxt_iprange.so" || -f "/usr/local/lib/xtables/libxt_iprange.so" ]] ; then \
		CONNMODULE="xt_iprange"
	fi
	if [[ -f "/lib/modules/${KERNVER}/kernel/net/netfilter/xt_connlimit.ko" || -f "/lib/xtables/libxt_connlimit.so" \
	|| -f "/usr/lib/xtables/libxt_connlimit.so" || -f "/usr/local/lib/xtables/libxt_connlimit.so" ]] ; then \
		CONNMODULE="xt_connlimit"
	fi
	if [[ $CONNMODULE == '' ]] ; then
		echo $RED"Conf error:$NORMAL ${B_WHITE}ENABLE_IPLIMIT$NORMAL requires CONFIG_NETFILTER_XT_MATCH_IPRANGE or CONFIG_NETFILTER_XT_MATCH_CONNLIMIT"
		echo "Missing xt_iprange.ko or libxt_iprange.so, xt_connlimit.ko or libxt_connlimit.so"
		confexit
	else
		/sbin/modprobe -a "$CONNMODULE" || confexit
	fi
fi

if [ "$EXECUTE_CUSTOM_SCRIPT" = 'yes' ] ; then
	if ! test -f $CUSTOM_SCRIPT ; then
		echo $RED"Conf error:$NORMAL Missing ${B_WHITE}${CUSTOM_SCRIPT}${NORMAL}"
		confexit
	fi
fi

#
# The fun stuff
#

# First setup some of the kernel features - Note: Setting these options only affect this host.  It has no
# on the rest of the network.
echo $B_WHITE"Initializing firewall (ip(6)tables)$NORMAL"

# Disable forwarding - should be already disabled, but just in case.
if [ "$ALWAYS_FORWARD" != 'yes' ] ; then
	echo -n "Turning off IP forwarding (will automatically re-enable if you turned on masqürading): "
	echo "0" >/proc/sys/net/ipv4/ip_forward && \
	echo "0" >/proc/sys/net/ipv6/conf/all/forwarding && \
	echo "0" >/proc/sys/net/ipv6/conf/default/forwarding && echo $RCOK || echo $RCFAIL
fi

# Enable syn-cookies (syn-flooding attacks)
# only IPv4
if [ "$SYNCOOKIES" != 'no' ] ; then
	echo -n "Enabling SYN-flood protection (syncookies): "
	echo "1" >/proc/sys/net/ipv4/tcp_syncookies && echo $RCOK || echo $RCFAIL
fi

# Disable ICMP echo-reqüst to broadcast addresses (smurf amplifier)
# only IPv4
if [ "$ANTI_SMURF" != 'no' ] ; then
	echo -n "Disable ICMP echo-reqüst to broadcast addresses (anti-smurf): "
	echo "1" >/proc/sys/net/ipv4/icmp_echo_ignore_broadcasts && echo $RCOK || echo $RCFAIL
	echo -n "Ignore bogus ICMP errors: "
	echo "1" >/proc/sys/net/ipv4/icmp_ignore_bogus_error_responses && \
	echo "0" >/proc/sys/net/ipv4/icmp_echo_ignore_all && echo $RCOK || echo $RCFAIL
fi

# Disable support for source-routed packets
# IPv4 and IPv6
if [ "$ACCEPT_SOURCE_ROUTE" != 'yes' ] ; then
	echo -n "Disabling source-routed packet support: "
	for interface in /proc/sys/net/ipv{4,6}/conf/{all,default} ; {
		echo "0" >$interface/accept_source_route && echo -n "[ ${B_WHITE}${interface}${NORMAL} - $RCOK ] " \
		|| echo -n "[ ${B_WHITE}${interface}${NORMAL} - $RCFAIL ] "
	}
	echo
fi

# Disable ICMP redirects.
# IPv4 and IPv6
if [ "$ACCEPT_REDIRECTS" != 'yes' ] ; then
	echo -n "Disabling ICMP redirects: "
	for interface in /proc/sys/net/ipv{4,6}/conf/{all,default} ; {
		echo "0" >$interface/accept_redirects && echo -n "[ ${B_WHITE}${interface}${NORMAL} - $RCOK ] " \
		|| echo -n "[ ${B_WHITE}${interface}${NORMAL} - $RCFAIL ] "
	}
	echo
fi

# Enable ingress filtering (source-address verification)
# only IPv4
if [ "$INGRESS_FILTER" != '' ] ; then
	echo -n "Enabling ingress filtering (level $INGRESS_FILTER) via rp_filter on interface: "
	for interface in /proc/sys/net/ipv4/conf/{all,default} ; {
		echo $INGRESS_FILTER >$interface/rp_filter && echo -n "[ ${B_WHITE}${interface}${NORMAL} - $RCOK ] " || echo -n \
		"[ ${B_WHITE}${interface}${NORMAL} - $RCFAIL ] "
	}
	echo
fi

# Log Martians (logs impossible source IP addresses)
# See /usr/src/linux/Documentation/networking/ip-sysctl.txt
# only IPv4
if [ "$LOG_MARTIANS" = 'yes' ] ; then
	echo -n "Log Martians on interface: "
	for interface in /proc/sys/net/ipv4/conf/{all,default} ; {
		echo "1" >$interface/log_martians && echo -n "[ ${B_WHITE}${interface}${NORMAL} - $RCOK ] " || echo -n \
		"[ ${B_WHITE}${interface}${NORMAL} - $RCFAIL ] "
	}
	echo
fi

# Enable dynamic IP workaround
# only IPv4
if [ "$DYNAMIC_EXTERNAL_IP" = 'yes' ] ; then
	echo -n "Enabling dynamic IP workaround: "
	echo "1" > /proc/sys/net/ipv4/ip_dynaddr && echo $RCOK || echo $RCFAIL
fi

# Disable TCP explicit congestion notification (tcp_ecn)
# only IPv4
echo -n "TCP Explicit Congestion Notification: $B_WHITE"
if [ "$ENABLE_TCP_ECN" = 'no' ] ; then
	echo "0" >/proc/sys/net/ipv4/tcp_ecn && echo DISABLED$NORMAL || echo FAILED
else
	echo "1" >/proc/sys/net/ipv4/tcp_ecn && echo ENABLED$NORMAL || echo FAILED
fi

# Enable dynamic IP workaround
# only IPv6
if [ "$TEMP_ADDR" = 'yes' ] ; then
	echo -n "Enabling IPv6 privacy addressing: "
	echo "2" > /proc/sys/net/ipv6/conf/all/use_tempaddr && \
	echo "2" > /proc/sys/net/ipv6/conf/default/use_tempaddr && echo $RCOK || echo $RCFAIL
	if [[ -n $TEMP_PREFERED_LFT ]] ; then
		echo -n "Configuration IPv6 address prefered time: "
		echo "$TEMP_PREFERED_LFT" > /proc/sys/net/ipv6/conf/all/temp_prefered_lft && \
		echo "$TEMP_PREFERED_LFT" > /proc/sys/net/ipv6/conf/default/temp_prefered_lft && \
		echo $RCOK || echo $RCFAIL
	fi
	if [[ -n $TEMP_VALID_LFT ]] ; then
		echo -n "Configuration IPv6 address valid time: "
		echo "$TEMP_VALID_LFT" > /proc/sys/net/ipv6/conf/all/temp_vaid_lft && \
		echo "$TEMP_VALID_LFT" > /proc/sys/net/ipv6/conf/default/temp_vaid_lft && \
		echo $RCOK || echo $RCFAIL
	fi
fi

# Preload some iptables modules
if [ "$LOAD_MODULES" = 'yes' ] ; then
	echo -n "Loading module: "
	for module in ${=PRELOAD_IP_MODULES} ; {
	    if ! grep $module ${TMPDIR}/kwnarc.tmp > /dev/null 2>&1 ; then
			/sbin/modprobe $module && echo -n "[ ${B_WHITE}${module}${NORMAL} - $RCOK ] " || echo -n \
			"[ ${B_WHITE}${module}${NORMAL} - $RCFAIL ] "
		fi
	}
	echo
fi

# Delete old chains
echo "Flushing/deleting chains "
# IPv4
$IPTABLES -F || abortexit
$IPTABLES -X || abortexit
$IPTABLES -F -t nat || abortexit
$IPTABLES -X -t nat || abortexit
$IPTABLES -F -t mangle || abortexit
$IPTABLES -X -t mangle || abortexit
# IPv6
$IP6TABLES -F || abortexit
$IP6TABLES -X || abortexit
$IP6TABLES -F -t nat || abortexit
$IP6TABLES -X -t nat || abortexit
$IP6TABLES -F -t mangle || abortexit
$IP6TABLES -X -t mangle || abortexit

# Set default policies
echo "Setting default policies: $B_WHITE"
# IPv4
$IPTABLES -P INPUT DROP || abortexit
$IPTABLES -P OUTPUT ACCEPT || abortexit
$IPTABLES -P FORWARD DROP || abortexit
$IPTABLES -L |grep Chain || abortexit
# IPv6
$IP6TABLES -P INPUT DROP || abortexit
$IP6TABLES -P OUTPUT ACCEPT || abortexit
$IP6TABLES -P FORWARD DROP || abortexit
$IP6TABLES -L |grep Chain || abortexit

# Custom chains used by kwnarc, IPv4 and IPv6
NEW_CHAINS="SPOOF_CHK SANITY_CHK STATE_CHK TCP_CHK UDP_CHK ICMP_CHK CUST_LOG"

# Create new chains
echo -n $NORMAL"Creating chains: "
for newchain in ${=NEW_CHAINS} ; {
	if [ "$LOG_DROPS" != 'no' ] ; then
		# IPv4
		$IPTABLES -N $newchain || abortexit
		# IPv6
		$IP6TABLES -N $newchain || abortexit
		echo -n "${B_WHITE}${newchain}${NORMAL} "
	else
		if [ "$newchain" != "CUST_LOG" ] ; then
			# IPv4
			$IPTABLES -N $newchain || abortexit
			# IPv6
			$IP6TABLES -N $newchain || abortexit
			echo -n "${B_WHITE}${newchain}${NORMAL} "
		fi
	fi
}
# only IPv6 RH_CHK
for newchain in RH_CHK ; {
	$IP6TABLES -N $newchain || abortexit
	echo -n "${B_WHITE}${newchain}${NORMAL} "
}
echo

##
## Assign optional options.
##

# Define DEFAULT_TARGET
if [ "$LOG_DROPS" = 'yes' ] ; then
	DEFAULT_TARGET='CUST_LOG'
else
	DEFAULT_TARGET='DROP'
fi

# Define LIMIT_OPT
if [ "$ENABLE_LIMIT_RATE" = 'yes' ] ; then
	LIMIT_OPT="-m limit --limit $LIMIT_RATE --limit-burst $LIMIT_BURST"
fi

# TCP packet length checking
if [ "$CHECK_SYN_PACKET_LENGTH" != 'no' ] ; then
	LENGTH_OPT="-m length --length $PACKET_LENGTH"
fi

# IP-address based rate limiting for TCP
if [ "$ENABLE_IPLIMIT" = 'yes' ] ; then
	IPLIMIT_OPT="-m ${CONNMODULE##*_} ! --${CONNMODULE##*_}-above $IPLIMIT_MAX_ACCEPT --${CONNMODULE##*_}-mask $IPLIMIT_NETMASK"
	#IPLIMIT_OPT="-m $CONNMODULE --connlimit-above 6"
fi

# SANITY_CHK target
if [[ "$LOG_DROPS" == 'yes' && "$LOG_ILLEGAL" == 'yes' ]] ; then
	ILLEGAL_TARGET='CUST_LOG'
else
	ILLEGAL_TARGET='DROP'
fi

# SPOOF_CHK target
if [[ "$LOG_DROPS" == 'yes' && "$LOG_SPOOF" == 'yes' ]] ; then
	SPOOF_TARGET='CUST_LOG'
else
	SPOOF_TARGET='DROP'
fi

# ICMP_CHK target
if [[ "$LOG_DROPS" == 'yes' && "$LOG_ICMP" == 'yes' ]] ; then
	ICMP_TARGET='CUST_LOG'
else
	ICMP_TARGET='DROP'
fi

##
## Drop broadcasts to the external interface
##

# IPv4
if [ "$DROP_BROADCASTS" = 'yes' ] ; then
	if [ "$BROADCAST_NETWORKS" != '' ] ; then
	echo -n "Dropping Broadcasts on ${B_WHITE}${EXTERNAL_INTERFACE}${NORMAL} to: "
		for network in ${=BROADCAST_NETWORKS} ; {
			$IPTABLES -t mangle -A PREROUTING -m state --state NEW -d $network \
				-i $EXTERNAL_INTERFACE -j DROP || abortexit
			echo -n "${B_WHITE}${network}${NORMAL} "
		}
		echo
		if [ "$PROTECT_FROM_LAN" = 'yes' ] ; then
			if [ "$LAN_INTERFACE" != '' ] ; then
				echo -n "Dropping Broadcasts on ${B_WHITE}${LAN_INTERFACE}${NORMAL} to: "
				for network in ${=BROADCAST_NETWORKS} ; {
					$IPTABLES -t mangle -A PREROUTING -m state --state NEW \
						-d $network -i $LAN_INTERFACE -j DROP || abortexit
					echo -n "${B_WHITE}${network}${NORMAL} "
				}
				echo
			fi
		fi
		if [ "$PROTECT_FROM_DMZ" = 'yes' ] ; then
			if [ "$DMZ_INTERFACE" != '' ] ; then
				echo -n "Dropping Broadcasts on ${B_WHITE}${DMZ_INTERFACE}${NORMAL} to: "
				for network in ${=BROADCAST_NETWORKS} ; {
					$IPTABLES -t mangle -A PREROUTING -m state --state NEW \
						-d $network -i $DMZ_INTERFACE -j DROP || abortexit
					echo -n "${B_WHITE}${network}${NORMAL} "
				}
				echo
			fi
		fi
	fi
fi

# IPv6
if [ "$DROP_BROADCASTS" = 'yes' ] ; then
	if [ "$BROADCAST_NETWORKS_IPV6" != '' ] ; then
	echo -n "Dropping IPv6 Broadcasts on ${B_WHITE}${EXTERNAL_INTERFACE}${NORMAL} to: "
		for network in ${=BROADCAST_NETWORKS_IPV6} ; {
			$IP6TABLES -t mangle -A PREROUTING -m state --state NEW -d $network \
				-i $EXTERNAL_INTERFACE -j DROP || abortexit
			echo -n "${B_WHITE}${network}${NORMAL} "
		}
		echo
		if [ "$PROTECT_FROM_LAN" = 'yes' ] ; then
			if [ "$LAN_INTERFACE" != '' ] ; then
				echo -n "Dropping IPv6 Broadcasts on ${B_WHITE}${LAN_INTERFACE}${NORMAL} to: "
				for network in ${=BROADCAST_NETWORKS_IPV6} ; {
					$IP6TABLES -t mangle -A PREROUTING -m state --state NEW \
						-d $network -i $LAN_INTERFACE -j DROP || abortexit
					echo -n "${B_WHITE}${network}${NORMAL} "
				}
				echo
			fi
		fi
		if [ "$PROTECT_FROM_DMZ" = 'yes' ] ; then
			if [ "$DMZ_INTERFACE" != '' ] ; then
				echo -n "Dropping IPv6 Broadcasts on ${B_WHITE}${DMZ_INTERFACE}${NORMAL} to: "
				for network in ${=BROADCAST_NETWORKS_IPV6} ; {
					$IP6TABLES -t mangle -A PREROUTING -m state --state NEW \
						-d $network -i $DMZ_INTERFACE -j DROP || abortexit
					echo -n "${B_WHITE}${network}${NORMAL} "
				}
				echo
			fi
		fi
	fi
fi

##
## Chain RH_CHK - drop packets with RH0 headers
##

# only IPv6
$IP6TABLES -A RH_CHK -m rt --rt-type 0 -j DROP || abortexit

##
## Chain SPOOF_CHK - Anti-spoofing checking for reserved and private IP addresses
##

# IPv4
if [ "$RESERVED_NETWORKS" != '' ] ; then
	echo -n "Enabling spoof checking on ${B_WHITE}${EXTERNAL_INTERFACE}${NORMAL} for reserved network(s): "
	for network in ${=RESERVED_NETWORKS} ; {
		$IPTABLES -A SPOOF_CHK -s $network -i $EXTERNAL_INTERFACE -j $SPOOF_TARGET || abortexit
		echo -n "${B_WHITE}${network}${NORMAL} "
	}
	echo
fi

if [ "$PRIVATE_NETWORKS" != '' ] ; then
	echo -n "Enabling spoof checking on ${B_WHITE}${EXTERNAL_INTERFACE}${NORMAL} for private network(s): "
	for network in ${=PRIVATE_NETWORKS} ; {
		IPVAL2="${EXTERNAL_INTERFACE_IP%%.*}"
		NETVAL2="${network%%.*}"
		if [[ $IPVAL2 == 10 && $NETVAL2 == 10 ]] ; then
			DONOTHING=1
		else
			IPVAL="${EXTERNAL_INTERFACE_IP%.*.*}"
			NETVAL="${network%.*.*}"
			if [ $IPVAL != $NETVAL ] ; then
				$IPTABLES -A SPOOF_CHK -s $network -i $EXTERNAL_INTERFACE \
					-j $SPOOF_TARGET || abortexit
			else
				DONOTHING=1
			fi
		fi
		if [ "$DONOTHING" != 1 ] ; then
			echo -n "${B_WHITE}${network}${NORMAL} "
		fi
	}
	echo
fi

if [ "$EXTERNAL_INTERFACE_IP" != '' ] ; then
	$IPTABLES -A SPOOF_CHK -s $EXTERNAL_INTERFACE_IP -i $EXTERNAL_INTERFACE -j $SPOOF_TARGET || abortexit
fi

# IPv6
if [ "$RESERVED_NETWORKS_IPV6" != '' ] ; then
	echo -n "Enabling spoof checking on ${B_WHITE}${EXTERNAL_INTERFACE}${NORMAL} for reserved network(s): "
	for network in ${=RESERVED_NETWORKS_IPV6} ; {
		$IP6TABLES -A SPOOF_CHK -s $network -i $EXTERNAL_INTERFACE -j $SPOOF_TARGET || abortexit
		echo -n "${B_WHITE}${network}${NORMAL} "
	}
	echo
fi

if [ "$PRIVATE_NETWORKS_IPV6" != '' ] ; then
	echo -n "Enabling spoof checking on ${B_WHITE}${EXTERNAL_INTERFACE}${NORMAL} for private network(s): "
	for network in ${=PRIVATE_NETWORKS_IPV6} ; {
		$IP6TABLES -A SPOOF_CHK -s $network -i $EXTERNAL_INTERFACE \
			-j $SPOOF_TARGET || abortexit
		echo -n "${B_WHITE}${network}${NORMAL} "
	}
	echo
fi

if [ "$EXTERNAL_INTERFACE_IPV6" != '' ] ; then
	$IP6TABLES -A SPOOF_CHK -s $EXTERNAL_INTERFACE_IPV6 -i $EXTERNAL_INTERFACE -j $SPOOF_TARGET || abortexit
fi

##
## Chain SANITY_CHK
##

# Check for illegal flags - usually evidence of a probe or worse

if [ "$ILLEGAL_TCP_FLAGS" != '' ] ; then
	echo -n "Enabling checking for illegal TCP flag types: "
	for flags in ${=ILLEGAL_TCP_FLAGS} ; {
		# IPv4
		$IPTABLES -A SANITY_CHK -p tcp --tcp-flags ALL $flags -j $ILLEGAL_TARGET || abortexit
		# IPv6
		$IP6TABLES -A SANITY_CHK -p tcp --tcp-flags ALL $flags -j $ILLEGAL_TARGET || abortexit
		echo -n "${B_WHITE}${flags}${NORMAL} "
	}
	echo
	# IPv4
	$IPTABLES -A SANITY_CHK -p tcp --tcp-flags ALL FIN -j $ILLEGAL_TARGET || abortexit
	$IPTABLES -A SANITY_CHK -p tcp --tcp-flags ALL NONE -j $ILLEGAL_TARGET || abortexit
	# IPv6
	$IP6TABLES -A SANITY_CHK -p tcp --tcp-flags ALL FIN -j $ILLEGAL_TARGET || abortexit
	$IP6TABLES -A SANITY_CHK -p tcp --tcp-flags ALL NONE -j $ILLEGAL_TARGET || abortexit
fi

# Drop unclean packets

if [ "$DROP_UNCLEAN_PACKETS" = 'yes' ] ; then
	# only IPv4, EXPERIMENTAL
	$IPTABLES -A SANITY_CHK -m unclean -j $DEFAULT_TARGET || abortexit
fi

##
## Chain STATE_CHK - Stateful checking to drop any new packets or packets not
## belonging to an existing connection
##

if [[ "$LOG_DROPS" == 'yes' && "$LOG_INVALID" == 'yes' ]] ; then
	LOG_INVALID_TARGET='CUST_LOG'
else
	LOG_INVALID_TARGET='DROP'
fi

# IPv4
$IPTABLES -A STATE_CHK -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT || abortexit
$IPTABLES -A STATE_CHK -m conntrack --ctstate INVALID -j $LOG_INVALID_TARGET || abortexit
$IPTABLES -A STATE_CHK -m conntrack --ctstate NEW -p tcp ! --syn -j $LOG_INVALID_TARGET || abortexit
# IPv6
$IP6TABLES -A STATE_CHK -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT || abortexit
$IP6TABLES -A STATE_CHK -m conntrack --ctstate INVALID -j $LOG_INVALID_TARGET || abortexit
$IP6TABLES -A STATE_CHK -m conntrack --ctstate NEW -p tcp ! --syn -j $LOG_INVALID_TARGET || abortexit


if [ "$LAN_INTERFACE" != '' ] ; then
	if [ "$PROTECT_FROM_LAN" = 'no' ] ; then
		# IPv4
		$IPTABLES -A STATE_CHK -m conntrack --ctstate NEW -i $LAN_INTERFACE -j ACCEPT || abortexit
		# IPv6
		$IP6TABLES -A STATE_CHK -m conntrack --ctstate NEW -i $LAN_INTERFACE -j ACCEPT || abortexit
	fi
fi
# Should this even be an option?
if [ "$DMZ_INTERFACE" != '' ] ; then
	if [ "$PROTECT_FROM_DMZ" = 'no' ] ; then
		# IPv4
		$IPTABLES -A STATE_CHK -m conntrack --ctstate NEW -i $DMZ_INTERFACE -j ACCEPT || abortexit
		# IPv6
		$IP6TABLES -A STATE_CHK -m conntrack --ctstate NEW -i $DMZ_INTERFACE -j ACCEPT || abortexit
	fi
fi

##
## Chain TCP_CHK
##

# Auth port response
if [ "$AUTH_REJECT" = 'yes' ] ; then
	echo "Reject packets to TCP auth port instead of drop"
	if [[ "$PROTECT_FROM_LAN" = 'no' && "$PROTECT_FROM_DMZ" = 'no' ]] ; then
		# IPv4
		$IPTABLES -I TCP_CHK -p tcp --syn --dport 113 \
			-j REJECT --reject-with tcp-reset || abortexit
		# IPv6
		$IP6TABLES -I TCP_CHK -p tcp --syn --dport 113 \
			-j REJECT --reject-with tcp-reset || abortexit
	else
		if [[ "$PROTECT_FROM_LAN" = 'yes' && "$PROTECT_FROM_DMZ" != 'yes' ]] ; then
			# IPv4
			$IPTABLES -I TCP_CHK -p tcp --syn --dport 113 -i $LAN_INTERFACE \
				-j REJECT --reject-with tcp-reset || abortexit
			# IPv6
			$IP6TABLES -I TCP_CHK -p tcp --syn --dport 113 -i $LAN_INTERFACE \
				-j REJECT --reject-with tcp-reset || abortexit
		fi
		if [[ "$PROTECT_FROM_LAN" != 'yes' && "$PROTECT_FROM_DMZ" = 'yes' ]] ; then
			# IPv4
			$IPTABLES -I TCP_CHK -p tcp --syn --dport 113 -i $DMZ_INTERFACE \
				-j REJECT --reject-with tcp-reset || abortexit
			# IPv6
			$IP6TABLES -I TCP_CHK -p tcp --syn --dport 113 -i $DMZ_INTERFACE \
				-j REJECT --reject-with tcp-reset || abortexit
		fi
		# IPv4
		$IPTABLES -I TCP_CHK -p tcp --syn --dport 113 -i $EXTERNAL_INTERFACE \
			-j REJECT --reject-with tcp-reset || abortexit
		# IPv6
		$IP6TABLES -I TCP_CHK -p tcp --syn --dport 113 -i $EXTERNAL_INTERFACE \
			-j REJECT --reject-with tcp-reset || abortexit
	fi
fi

# Allowed TCP ports - external access
if [ "$ALLOW_TCP_EXT" != '' ] ; then
	echo -n "Allow external connections on ${B_WHITE}${EXTERNAL_INTERFACE}${NORMAL} TCP ports: "
	# IPv4
	$IPTABLES -A TCP_CHK -m multiport -m state --state NEW -p tcp ${=LENGTH_OPT} ${=LIMIT_OPT} \
		--dport $ALLOW_TCP_EXT --syn -i $EXTERNAL_INTERFACE -j ACCEPT || abortexit
	# IPv6
	$IP6TABLES -A TCP_CHK -m multiport -m state --state NEW -p tcp ${=LENGTH_OPT} ${=LIMIT_OPT} \
		--dport $ALLOW_TCP_EXT --syn -i $EXTERNAL_INTERFACE -j ACCEPT || abortexit
	echo -n "${B_WHITE}${ALLOW_TCP_EXT}${NORMAL} "
	echo
fi
if [ "$ALLOW_TCP_EXT_RANGE" != '' ] ; then
	echo -n "Allow external connections on ${B_WHITE}${EXTERNAL_INTERFACE}${NORMAL} TCP ports: "
	for ports in ${=ALLOW_TCP_EXT_RANGE} ; {
		# IPv4
		$IPTABLES -A TCP_CHK -m state --state NEW -p tcp ${=LENGTH_OPT} ${=LIMIT_OPT} \
			${=IPLIMIT_OPT} --dport $ports --syn -i $EXTERNAL_INTERFACE -j ACCEPT || abortexit
		# IPv6
		$IP6TABLES -A TCP_CHK -m state --state NEW -p tcp ${=LENGTH_OPT} ${=LIMIT_OPT} \
			${=IPLIMIT_OPT} --dport $ports --syn -i $EXTERNAL_INTERFACE -j ACCEPT || abortexit
		echo -n "${B_WHITE}${ports}${NORMAL} "
	}
	echo
fi

# Allowed TCP ports - LAN access
if [ "$PROTECT_FROM_LAN" != 'no' ] ; then
	if [[ "$ALLOW_TCP_LAN" != '' && "$LAN_INTERFACE" != '' ]] ; then
		echo -n "Allow LAN connections on ${B_WHITE}${LAN_INTERFACE}${NORMAL} TCP ports: "
		# IPv4
		$IPTABLES -A TCP_CHK -m multiport -m state --state NEW -p tcp ${=LENGTH_OPT} \
			${=LIMIT_OPT} ${=IPLIMIT_OPT} --dport $ALLOW_TCP_LAN --syn \
			-i $LAN_INTERFACE -j ACCEPT || abortexit
		# IPv6
		$IP6TABLES -A TCP_CHK -m multiport -m state --state NEW -p tcp ${=LENGTH_OPT} \
			${=LIMIT_OPT} ${=IPLIMIT_OPT} --dport $ALLOW_TCP_LAN --syn \
			-i $LAN_INTERFACE -j ACCEPT || abortexit
		echo -n "${B_WHITE}${ALLOW_TCP_LAN}${NORMAL} "
		echo
	fi
	if [ "$ALLOW_TCP_LAN_RANGE" != '' ] ; then
		echo -n "Allow LAN connections on ${B_WHITE}${LAN_INTERFACE}${NORMAL} TCP ports: "
		for ports in ${=ALLOW_TCP_LAN_RANGE} ; {
			# IPv4
			$IPTABLES -A TCP_CHK -m state --state NEW -p tcp ${=LENGTH_OPT} ${=LIMIT_OPT} \
				${=IPLIMIT_OPT} --dport $ports --syn -i $LAN_INTERFACE -j ACCEPT || abortexit
			# IPv6
			$IP6TABLES -A TCP_CHK -m state --state NEW -p tcp ${=LENGTH_OPT} ${=LIMIT_OPT} \
				${=IPLIMIT_OPT} --dport $ports --syn -i $LAN_INTERFACE -j ACCEPT || abortexit
			echo -n "${B_WHITE}${ports}${NORMAL} "
		}
		echo
	fi
fi

# Allowed TCP ports - DMZ access
if [ "$PROTECT_FROM_DMZ" != 'no' ] ; then
	if [ "$ALLOW_TCP_DMZ" != '' ] ; then
		echo -n "Allow DMZ connections on ${B_WHITE}${DMZ_INTERFACE}${NORMAL} TCP ports: "
		# IPv4
		$IPTABLES -A TCP_CHK -m multiport -m state --state NEW -p tcp ${=LENGTH_OPT} \
			${=LIMIT_OPT} ${=IPLIMIT_OPT} --dport $ALLOW_TCP_DMZ --syn \
			-i $DMZ_INTERFACE -j ACCEPT || abortexit
		# IPv6
		$IP6TABLES -A TCP_CHK -m multiport -m state --state NEW -p tcp ${=LENGTH_OPT} \
			${=LIMIT_OPT} ${=IPLIMIT_OPT} --dport $ALLOW_TCP_DMZ --syn \
			-i $DMZ_INTERFACE -j ACCEPT || abortexit
		echo -n "${B_WHITE}${ALLOW_TCP_DMZ}${NORMAL} "
		echo
	fi
	if [ "$ALLOW_TCP_DMZ_RANGE" != '' ] ; then
		echo -n "Allow DMZ connections on ${B_WHITE}${DMZ_INTERFACE}${NORMAL} TCP ports: "
		for ports in ${=ALLOW_TCP_DMZ_RANGE} ; {
			# IPv4
			$IPTABLES -A TCP_CHK -m state --state NEW -p tcp ${=LENGTH_OPT} ${=LIMIT_OPT} \
				${=IPLIMIT_OPT} --dport $ports --syn -i $DMZ_INTERFACE -j ACCEPT || abortexit
			# IPv6
			$IP6TABLES -A TCP_CHK -m state --state NEW -p tcp ${=LENGTH_OPT} ${=LIMIT_OPT} \
				${=IPLIMIT_OPT} --dport $ports --syn -i $DMZ_INTERFACE -j ACCEPT || abortexit
			echo -n "${B_WHITE}${ports}${NORMAL} "
		}
		echo
	fi
fi

# BIND workaround IPv4 - TCP
if [[ "$PROTECT_FROM_LAN" != 'no' || "$PROTECT_FROM_DMZ" != 'no' ]] ; then
	# there must be a better way to do this
	if [ "$BIND_IP" != '' ] ; then
		for ip in ${=BIND_IP} ; {
			$IPTABLES -A TCP_CHK -m state --state NEW -p tcp --dport 53 -s $ip -i lo \
				-j ACCEPT || abortexit
		}
	fi
fi
# BIND workaround IPv6 - TCP
if [[ "$PROTECT_FROM_LAN" != 'no' || "$PROTECT_FROM_DMZ" != 'no' ]] ; then
	# there must be a better way to do this
	if [ "$BIND_IPV6" != '' ] ; then
		for ip in ${=BIND_IPV6} ; {
			$IP6TABLES -A TCP_CHK -m state --state NEW -p tcp --dport 53 -s $ip -i lo \
				-j ACCEPT || abortexit
		}
	fi
fi

# IPv4
$IPTABLES -A TCP_CHK -j $DEFAULT_TARGET || abortexit
# IPv6
$IP6TABLES -A TCP_CHK -j $DEFAULT_TARGET || abortexit


##
## Chain UDP_CHK
##

# IPv4
# allow dhcp client to work
$IPTABLES -A UDP_CHK -p udp --sport 67 --dport 68 -j ACCEPT || abortexit

# allow MULTICAST mDNS for service discovery (be sure the MULTICAST line above
# is uncommented)
$IPTABLES -A UDP_CHK -p udp -d 224.0.0.251 --dport 5353 -j ACCEPT || abortexit

# allow MULTICAST UPnP for service discovery (be sure the MULTICAST line above
# is uncommented)
$IPTABLES -A UDP_CHK -p udp -d 239.255.255.250 --dport 1900 -j ACCEPT || abortexit

# IPv6
$IP6TABLES -A UDP_CHK -p udp -s fe80::/10 --sport 547 -d fe80::/10 --dport 546 -j ACCEPT || abortexit

# allow MULTICAST mDNS for service discovery
$IP6TABLES -A UDP_CHK -p udp -d ff02::fb --dport 5353 -j ACCEPT || abortexit

# allow MULTICAST UPnP for service discovery
$IP6TABLES -A UDP_CHK -p udp -d ff02::f --dport 1900 -j ACCEPT || abortexit

# Allowed UDP ports
if [ "$ALLOW_UDP_EXT" != '' ] ; then
	echo -n "Allow external connections on ${B_WHITE}${EXTERNAL_INTERFACE}${NORMAL} UDP ports: "
	# IPv4
	$IPTABLES -A UDP_CHK -m multiport -m state --state NEW ${=LIMIT_OPT} -p udp --dport $ALLOW_UDP_EXT \
		-i $EXTERNAL_INTERFACE -j ACCEPT || abortexit
	# IPv6
	$IP6TABLES -A UDP_CHK -m multiport -m state --state NEW ${=LIMIT_OPT} -p udp --dport $ALLOW_UDP_EXT \
		-i $EXTERNAL_INTERFACE -j ACCEPT || abortexit
	echo -n "${B_WHITE}${ALLOW_UDP_EXT}${NORMAL} "
	echo
fi
if [ "$ALLOW_UDP_EXT_RANGE" != '' ] ; then
	echo -n "Allow external connections on ${B_WHITE}${EXTERNAL_INTERFACE}${NORMAL} UDP ports: "
	for ports in ${=ALLOW_UDP_EXT_RANGE} ; {
		# IPv4
		$IPTABLES -A UDP_CHK -m state --state NEW ${=LIMIT_OPT} -p udp --dport $ports \
			-i $EXTERNAL_INTERFACE -j ACCEPT || abortexit
		# IPv6
		$IP6TABLES -A UDP_CHK -m state --state NEW ${=LIMIT_OPT} -p udp --dport $ports \
			-i $EXTERNAL_INTERFACE -j ACCEPT || abortexit
		echo -n "${B_WHITE}${ports}${NORMAL} "
	}
	echo
fi

# Allowed UDP ports - LAN access
if [ "$PROTECT_FROM_LAN" != 'no' ] ; then
	if [ "$ALLOW_UDP_LAN" != '' ] ; then
		echo -n "Allow LAN connections on ${B_WHITE}${LAN_INTERFACE}${NORMAL} UDP ports: "
		# IPv4
		$IPTABLES -A UDP_CHK -m multiport -m state --state NEW ${=LIMIT_OPT} -p udp \
			--dport $ALLOW_UDP_LAN -i $LAN_INTERFACE -j ACCEPT || abortexit
		# IPv6
		$IP6TABLES -A UDP_CHK -m multiport -m state --state NEW ${=LIMIT_OPT} -p udp \
			--dport $ALLOW_UDP_LAN -i $LAN_INTERFACE -j ACCEPT || abortexit
		echo -n "${B_WHITE}${ALLOW_UDP_LAN}${NORMAL} "
		echo
	fi
	if [ "$ALLOW_UDP_LAN_RANGE" != '' ] ; then
		echo -n "Allow LAN connections on ${B_WHITE}${LAN_INTERFACE}${NORMAL} UDP ports: "
		for ports in ${=ALLOW_UDP_LAN_RANGE} ; {
			# IPv4
			$IPTABLES -A UDP_CHK -m state --state NEW ${=LIMIT_OPT} -p udp --dport $ports \
				-i $LAN_INTERFACE -j ACCEPT || abortexit
			# IPv6
			$IP6TABLES -A UDP_CHK -m state --state NEW ${=LIMIT_OPT} -p udp --dport $ports \
				-i $LAN_INTERFACE -j ACCEPT || abortexit
			echo -n "${B_WHITE}${ports}${NORMAL} "
		}
		echo
	fi
fi

# Allowed UDP ports - DMZ access
if [ "$PROTECT_FROM_DMZ" != 'no' ] ; then
	if [ "$ALLOW_UDP_DMZ" != '' ] ; then
		echo -n "Allow DMZ connections on ${B_WHITE}${DMZ_INTERFACE}${NORMAL} UDP ports: "
		# IPv4
		$IPTABLES -A UDP_CHK -m multiport -m state --state NEW ${=LIMIT_OPT} -p udp \
			--dport $ALLOW_UDP_DMZ -i $DMZ_INTERFACE -j ACCEPT || abortexit
		# IPv6
		$IP6TABLES -A UDP_CHK -m multiport -m state --state NEW ${=LIMIT_OPT} -p udp \
			--dport $ALLOW_UDP_DMZ -i $DMZ_INTERFACE -j ACCEPT || abortexit
		echo -n "${B_WHITE}${ALLOW_UDP_DMZ}${NORMAL} "
	echo
	fi
	if [ "$ALLOW_UDP_DMZ_RANGE" != '' ] ; then
		echo -n "Allow DMZ connections on ${B_WHITE}${DMZ_INTERFACE}${NORMAL} UDP ports: "
		for ports in ${=ALLOW_UDP_DMZ_RANGE} ; {
			# IPv4
			$IPTABLES -A UDP_CHK -m state --state NEW ${=LIMIT_OPT} -p udp --dport $ports \
				-i $DMZ_INTERFACE -j ACCEPT || abortexit
			# IPv6
			$IP6TABLES -A UDP_CHK -m state --state NEW ${=LIMIT_OPT} -p udp --dport $ports \
				-i $DMZ_INTERFACE -j ACCEPT || abortexit
			echo -n "${B_WHITE}${ports}${NORMAL} "
		}
		echo
	fi
fi

# BIND workaround IPv4 - UDP
if [[ "$PROTECT_FROM_LAN" != 'no' || "$PROTECT_FROM_DMZ" != 'no' ]] ; then
	# there must be a better way to do this
	if [ "$BIND_IP" != '' ] ; then
		for ip in ${=BIND_IP} ; {
			$IPTABLES -A UDP_CHK -m state --state NEW -p udp --dport 53 -s $ip -i lo \
			-j ACCEPT || abortexit
		}
	fi
fi
# BIND workaround IPv6 - UDP
if [[ "$PROTECT_FROM_LAN" != 'no' || "$PROTECT_FROM_DMZ" != 'no' ]] ; then
	# there must be a better way to do this
	if [ "$BIND_IPV6" != '' ] ; then
		for ip in ${=BIND_IPV6} ; {
			$IP6TABLES -A UDP_CHK -m state --state NEW -p udp --dport 53 -s $ip -i lo \
			-j ACCEPT || abortexit
		}
	fi
fi

# Traceroute workaround for UNIX hosts - is there a better way to do this?
if [ "$ANSWER_TRACEROUTE" = 'yes' ] ; then
	echo "Firewall will answer traceroutes (not recommended)"
	# IPv4
	$IPTABLES -A UDP_CHK -m state --state NEW -m limit --limit $PING_RATE --limit-burst $BURST_MAX \
		-p udp  --dport 33434:38000 -j ACCEPT || abortexit
	# IPv5
	$IP6TABLES -A UDP_CHK -m state --state NEW -m limit --limit $PING_RATE --limit-burst $BURST_MAX \
		-p udp  --dport 33434:38000 -j ACCEPT || abortexit
fi

# IPv4
$IPTABLES -A UDP_CHK -j $DEFAULT_TARGET || abortexit
# IPv6
$IP6TABLES -A UDP_CHK -j $DEFAULT_TARGET || abortexit

##
## ICMP_CHK section
##

# ok icmp codes for INPUT (rfc4890, 4.4.1 and 4.4.2)
# ok icmp codes for OUTPUT (rfc4890, 4.4.1 and 4.4.2)
# only IPv6
echo -n "Enabling NDP ICMPv6 message types: "
NDP_ICMPV6_MESSAGE="neighbor-solicitation neighbor-advertisement router-solicitation router-advertisement"
for mtype in ${=NDP_ICMPV6_MESSAGE} ; {
	$IP6TABLES -A ICMP_CHK -p icmpv6 --icmpv6-type $mtype -m hl --hl-eq 255 -j ACCEPT || abortexit
	echo -n "${B_WHITE}${mtype}${NORMAL} "
}

# for multicast ping replies from link-local addresses (these don't have an
# associated connection and would otherwise be marked INVALID)
$IP6TABLES -A ICMP_CHK -p icmpv6 --icmpv6-type echo-reply -s fe80::/10 -j ACCEPT || abortexit
# IND solicitation
$IP6TABLES -A ICMP_CHK -p icmpv6 --icmpv6-type 141 -m hl --hl-eq 255 -j ACCEPT || abortexit
# IND advertisement
$IP6TABLES -A ICMP_CHK -p icmpv6 --icmpv6-type 142 -m hl --hl-eq 255 -j ACCEPT || abortexit
# MLD qüry
$IP6TABLES -A ICMP_CHK -p icmpv6 --icmpv6-type 130 -s fe80::/10 -j ACCEPT || abortexit
# MLD report
$IP6TABLES -A ICMP_CHK -p icmpv6 --icmpv6-type 131 -s fe80::/10 -j ACCEPT || abortexit
# MLD done
$IP6TABLES -A ICMP_CHK -p icmpv6 --icmpv6-type 132 -s fe80::/10 -j ACCEPT || abortexit
# MLD report v2
$IP6TABLES -A ICMP_CHK -p icmpv6 --icmpv6-type 143 -s fe80::/10 -j ACCEPT || abortexit
# SEND certificate path solicitation
$IP6TABLES -A ICMP_CHK -p icmpv6 --icmpv6-type 148 -m hl --hl-eq 255 -j ACCEPT || abortexit
# SEND certificate path advertisement
$IP6TABLES -A ICMP_CHK -p icmpv6 --icmpv6-type 149 -m hl --hl-eq 255 -j ACCEPT || abortexit
# MR advertisement
$IP6TABLES -A ICMP_CHK -p icmpv6 --icmpv6-type 151 -s fe80::/10 -m hl --hl-eq 1 -j ACCEPT || abortexit
# MR solicitation
$IP6TABLES -A ICMP_CHK -p icmpv6 --icmpv6-type 152 -s fe80::/10 -m hl --hl-eq 1 -j ACCEPT || abortexit
# MR termination
$IP6TABLES -A ICMP_CHK -p icmpv6 --icmpv6-type 153 -s fe80::/10 -m hl --hl-eq 1 -j ACCEPT || abortexit

# ok icmp codes for FORWARD (rfc4890, 4.3.2)
# Home Agent Address Discovery Reqüs
$IP6TABLES -A ICMP_CHK -p icmpv6 --icmpv6-type 144 -j ACCEPT
# Home Agent Address Discovery Reply
$IP6TABLES -A ICMP_CHK -p icmpv6 --icmpv6-type 145 -j ACCEPT
# Mobile Prefix Solicitation
$IP6TABLES -A ICMP_CHK -p icmpv6 --icmpv6-type 146 -j ACCEPT
# Mobile Prefix Advertisement
$IP6TABLES -A ICMP_CHK -p icmpv6 --icmpv6-type 147 -j ACCEPT

# To answer or not to answer
if [ "$ANSWER_PING" = 'yes' ] ; then
	echo "Firewall will answer pings"
	# IPv4
	$IPTABLES -A ICMP_CHK -p icmp --icmp-type echo-reqüst -m limit --limit $PING_RATE \
		--limit-burst $BURST_MAX -j ACCEPT || abortexit
	# IPv6
	$IP6TABLES -A ICMP_CHK -p icmpv6 --icmpv6-type echo-reqüst -m limit --limit $PING_RATE \
		--limit-burst $BURST_MAX -j ACCEPT || abortexit
fi

# Allow other ICMP messages
if [ "$ALLOW_ICMP_MESSAGE" != '' ] ; then
	echo -n "Enabling ICMP message types: "
	for mtype in ${=ALLOW_ICMP_MESSAGE} ; {
		$IPTABLES -A ICMP_CHK -p icmp --icmp-type $mtype -m limit --limit $PING_RATE \
			--limit-burst $BURST_MAX -j ACCEPT || abortexit
		echo -n "${B_WHITE}${mtype}${NORMAL} "
	}
	echo
fi
# Allow other ICMPV6 messages
if [ "$ALLOW_ICMPV6_MESSAGE" != '' ] ; then
	echo -n "Enabling ICMPv6 message types: "
	for mtype in ${=ALLOW_ICMPV6_MESSAGE} ; {
		$IP6TABLES -A ICMP_CHK -p icmpv6 --icmpv6-type $mtype -m limit --limit $PING_RATE \
			--limit-burst $BURST_MAX -j ACCEPT || abortexit
		echo -n "${B_WHITE}${mtype}${NORMAL} "
	}
	echo
fi

# IPv4
$IPTABLES -A ICMP_CHK -j $ICMP_TARGET || abortexit
# IPv6
$IP6TABLES -A ICMP_CHK -j $ICMP_TARGET || abortexit

##
## Chain CUST_LOG - customized logging rules
## Comment: Doesn't seem the most efficient way to log traffic.  Currently packets are matched three
## times before being dropped.  Once to jumped to this chain, again to be logged with customized options,
## and finally explicitly matched and dropped to avoid duplicate log entries if LOG_ALL_ELSE is enabled.
##

# Log Spoofed traffic
# IPv4
if [[ "$LOG_DROPS" == 'yes' && "$LOG_SPOOF" == 'yes' ]] ; then
	if [ "$RESERVED_NETWORKS" != '' ] ; then
		for network in ${=RESERVED_NETWORKS} ; {
			$IPTABLES -A CUST_LOG -s $network -i $EXTERNAL_INTERFACE -j LOG --log-level $WARN_LOG_LEVEL \
				--log-prefix "SPOOF " --log-ip-options --log-tcp-options || abortexit
			if [ "$LOG_ALL_ELSE" = 'yes' ] ; then
				$IPTABLES -A CUST_LOG -s $network -i $EXTERNAL_INTERFACE -j DROP || abortexit
			fi
		}
	fi
	if [ "$PRIVATE_NETWORKS" != '' ] ; then
		for network in ${=PRIVATE_NETWORKS} ; {
			IPVAL2="${EXTERNAL_INTERFACE_IP%%.*}"
			NETVAL2="${network%%.*}"
			if [[ $IPVAL2 = 10 && $NETVAL2 = 10 ]] ; then
					echo 1 > /dev/null
			else
				IPVAL="${EXTERNAL_INTERFACE_IP%.*.*}"
				NETVAL="${network%.*.*}"
					if [ $IPVAL != $NETVAL ] ; then
						$IPTABLES -A CUST_LOG -s $network -i $EXTERNAL_INTERFACE \
						-j LOG --log-level $WARN_LOG_LEVEL --log-prefix "SPOOF " \
						--log-ip-options --log-tcp-options || abortexit
						if [ "$LOG_ALL_ELSE" = 'yes' ] ; then
							$IPTABLES -A CUST_LOG -s $network \
							-i $EXTERNAL_INTERFACE -j DROP || abortexit
						fi
					fi
			fi
		}
	fi
	# IPv4
	if [ "$EXTERNAL_INTERFACE_IP" != '' ] ; then
		$IPTABLES -A CUST_LOG -s $EXTERNAL_INTERFACE_IP -i $EXTERNAL_INTERFACE -j LOG \
			--log-level $WARN_LOG_LEVEL --log-prefix "SPOOF " --log-ip-options \
			--log-tcp-options || abortexit
		if [ "$LOG_ALL_ELSE" = 'yes' ] ; then
			$IPTABLES -A CUST_LOG -s $EXTERNAL_INTERFACE_IP -i $EXTERNAL_INTERFACE \
				-j DROP || abortexit
		fi
	fi
fi
# IPv6
if [[ "$LOG_DROPS" == 'yes' && "$LOG_SPOOF" == 'yes' ]] ; then
	if [ "$RESERVED_NETWORKS_IPV6" != '' ] ; then
		for network in ${=RESERVED_NETWORKS_IPV6} ; {
			$IP6TABLES -A CUST_LOG -s $network -i $EXTERNAL_INTERFACE -j LOG --log-level $WARN_LOG_LEVEL \
				--log-prefix "SPOOF " --log-ip-options --log-tcp-options || abortexit
			if [ "$LOG_ALL_ELSE" = 'yes' ] ; then
				$IP6TABLES -A CUST_LOG -s $network -i $EXTERNAL_INTERFACE -j DROP || abortexit
			fi
		}
	fi
	if [ "$PRIVATE_NETWORKS_IPV6" != '' ] ; then
		for network in ${=PRIVATE_NETWORKS_IPV6} ; {
			$IP6TABLES -A CUST_LOG -s $network -i $EXTERNAL_INTERFACE \
				-j LOG --log-level $WARN_LOG_LEVEL --log-prefix "SPOOF " \
				--log-ip-options --log-tcp-options || abortexit
			if [ "$LOG_ALL_ELSE" = 'yes' ] ; then
				$IP6TABLES -A CUST_LOG -s $network \
					-i $EXTERNAL_INTERFACE -j DROP || abortexit
			fi
		}
	fi
	# IPv6
	if [ "$EXTERNAL_INTERFACE_IPV6" != '' ] ; then
		$IP6TABLES -A CUST_LOG -s $EXTERNAL_INTERFACE_IPV6 -i $EXTERNAL_INTERFACE -j LOG \
			--log-level $WARN_LOG_LEVEL --log-prefix "SPOOF " --log-ip-options \
			--log-tcp-options || abortexit
		if [ "$LOG_ALL_ELSE" = 'yes' ] ; then
			$IP6TABLES -A CUST_LOG -s $EXTERNAL_INTERFACE_IPV6 -i $EXTERNAL_INTERFACE \
				-j DROP || abortexit
		fi
	fi
fi

# Log TCP packets with illegal TCP flags - usually evidence of a probe or worse
if [[ "$LOG_DROPS" == 'yes' && "$LOG_ILLEGAL" == 'yes' ]] ; then
	if [ "$ILLEGAL_TCP_FLAGS" != '' ] ; then
		for flags in ${=ILLEGAL_TCP_FLAGS} ; {
			# IPv4
			$IPTABLES -A CUST_LOG -p tcp --tcp-flags ALL $flags -j LOG --log-level $WARN_LOG_LEVEL \
			--log-prefix "ILLEGAL " --log-ip-options --log-tcp-options || abortexit
			# IPv6
			$IP6TABLES -A CUST_LOG -p tcp --tcp-flags ALL $flags -j LOG --log-level $WARN_LOG_LEVEL \
			--log-prefix "ILLEGAL " --log-ip-options --log-tcp-options || abortexit
			if [ "$LOG_ALL_ELSE" = 'yes' ] ; then
				# IPv4
				$IPTABLES -A CUST_LOG -p tcp --tcp-flags ALL $flags -j DROP || abortexit
				# IPv6
				$IP6TABLES -A CUST_LOG -p tcp --tcp-flags ALL $flags -j DROP || abortexit
			fi
		}
		## ACK scans
		# IPv4
		$IPTABLES -A CUST_LOG -m state --state NEW -p tcp --tcp-flags ALL ACK -j LOG \
			--log-level $WARN_LOG_LEVEL --log-prefix "ACKSCAN " --log-ip-options \
			--log-tcp-options || abortexit
		# IPv6
		$IP6TABLES -A CUST_LOG -m state --state NEW -p tcp --tcp-flags ALL ACK -j LOG \
			--log-level $WARN_LOG_LEVEL --log-prefix "ACKSCAN " --log-ip-options \
			--log-tcp-options || abortexit
		if [ "$LOG_ALL_ELSE" = 'yes' ] ; then
			# IPv4
			$IPTABLES -A CUST_LOG -m state --state NEW -p tcp --tcp-flags ALL ACK -j DROP || abortexit
			# IPv6
			$IP6TABLES -A CUST_LOG -m state --state NEW -p tcp --tcp-flags ALL ACK -j DROP || abortexit
		fi
		## FIN scans
		# IPv4
		$IPTABLES -A CUST_LOG -p tcp --tcp-flags ALL $FINSCAN -j LOG --log-level $WARN_LOG_LEVEL \
			--log-prefix "FINSCAN " --log-ip-options --log-tcp-options || abortexit
		# IPv6
		$IP6TABLES -A CUST_LOG -p tcp --tcp-flags ALL $FINSCAN -j LOG --log-level $WARN_LOG_LEVEL \
			--log-prefix "FINSCAN " --log-ip-options --log-tcp-options || abortexit
		if [ "$LOG_ALL_ELSE" = 'yes' ] ; then
			# IPv4
			$IPTABLES -A CUST_LOG -p tcp --tcp-flags ALL $FINSCAN -j DROP || abortexit
			# IPv6
			$IP6TABLES -A CUST_LOG -p tcp --tcp-flags ALL $FINSCAN -j DROP || abortexit
		fi
		## XMAS scans
		# IPv4
		$IPTABLES -A CUST_LOG -p tcp --tcp-flags ALL $XMASSCAN -j LOG --log-level $WARN_LOG_LEVEL \
			--log-prefix "XMASSCAN " --log-ip-options --log-tcp-options || abortexit
		# IPv6
		$IP6TABLES -A CUST_LOG -p tcp --tcp-flags ALL $XMASSCAN -j LOG --log-level $WARN_LOG_LEVEL \
			--log-prefix "XMASSCAN " --log-ip-options --log-tcp-options || abortexit
		if [ "$LOG_ALL_ELSE" = 'yes' ] ; then
			# IPv4
			$IPTABLES -A CUST_LOG -p tcp --tcp-flags ALL $XMASSCAN -j DROP || abortexit
			# IPv6
			$IP6TABLES -A CUST_LOG -p tcp --tcp-flags ALL $XMASSCAN -j DROP || abortexit
		fi
		## Null scans
		# IPv4
		$IPTABLES -A CUST_LOG -p tcp --tcp-flags ALL $NULLSCAN -j LOG --log-level $WARN_LOG_LEVEL \
			--log-prefix "NULLSCAN " --log-ip-options --log-tcp-options || abortexit
		# IPv6
		$IP6TABLES -A CUST_LOG -p tcp --tcp-flags ALL $NULLSCAN -j LOG --log-level $WARN_LOG_LEVEL \
			--log-prefix "NULLSCAN " --log-ip-options --log-tcp-options || abortexit
		if [ "$LOG_ALL_ELSE" = 'yes' ] ; then
			# IPv4
			$IPTABLES -A CUST_LOG -p tcp --tcp-flags ALL $NULLSCAN -j DROP || abortexit
			# IPv6
			$IP6TABLES -A CUST_LOG -p tcp --tcp-flags ALL $NULLSCAN -j DROP || abortexit
		fi
	fi
	## Unclean
	if [ "$DROP_UNCLEAN_PACKETS" = 'yes' ] ; then
		# IPv4
		$IPTABLES -A CUST_LOG -m unclean -j LOG --log-level $WARN_LOG_LEVEL --log-prefix "UNCLEAN " \
			--log-ip-options --log-tcp-options || abortexit
		# IPv6
		$IP6TABLES -A CUST_LOG -m unclean -j LOG --log-level $WARN_LOG_LEVEL --log-prefix "UNCLEAN " \
			--log-ip-options --log-tcp-options || abortexit
		if [ "$LOG_ALL_ELSE" = 'yes' ] ; then
			# IPv4
			$IPTABLES -A CUST_LOG -m unclean -j DROP || abortexit
			# IPv6
			$IP6TABLES -A CUST_LOG -m unclean -j DROP || abortexit
		fi
	fi
fi

# Log probable probes
if [[ "$LOG_DROPS" == 'yes' && "$LOG_PROBES" == 'yes' ]] ; then
	if [ "$TCP_PROBE" != '' ] ; then
		echo -n "Enabling probable probe logging [TCP]: "
		# IPv4
		$IPTABLES -A CUST_LOG -m multiport -p tcp --dport $TCP_PROBE -j LOG --log-level $WARN_LOG_LEVEL \
			--log-tcp-options --log-ip-options --log-prefix "PROBE " || abortexit
		# IPv6
		$IP6TABLES -A CUST_LOG -m multiport -p tcp --dport $TCP_PROBE -j LOG --log-level $WARN_LOG_LEVEL \
			--log-tcp-options --log-ip-options --log-prefix "PROBE " || abortexit
		if [ "$LOG_ALL_ELSE" = 'yes' ] ; then
			# IPv4
			$IPTABLES -A CUST_LOG -m multiport -p tcp --dport $TCP_PROBE -j DROP || abortexit
			# IPv6
			$IP6TABLES -A CUST_LOG -m multiport -p tcp --dport $TCP_PROBE -j DROP || abortexit
		fi
		echo -n "${B_WHITE}${TCP_PROBE}${NORMAL}"
		if [ "$TCP_PROBE2" != '' ] ; then
			# IPv4
			$IPTABLES -A CUST_LOG -m multiport -p tcp --dport $TCP_PROBE2 -j LOG \
				--log-level $WARN_LOG_LEVEL --log-tcp-options --log-ip-options \
				--log-prefix "PROBE " || abortexit
			# IPv6
			$IP6TABLES -A CUST_LOG -m multiport -p tcp --dport $TCP_PROBE2 -j LOG \
				--log-level $WARN_LOG_LEVEL --log-tcp-options --log-ip-options \
				--log-prefix "PROBE " || abortexit
			if [ "$LOG_ALL_ELSE" = 'yes' ] ; then
				# IPv4
				$IPTABLES -A CUST_LOG -m multiport -p tcp --dport $TCP_PROBE2 -j DROP || abortexit
				# IPv6
				$IP6TABLES -A CUST_LOG -m multiport -p tcp --dport $TCP_PROBE2 -j DROP || abortexit
			fi
			echo -n "${B_WHITE},${TCP_PROBE2}${NORMAL}"
		fi
		echo
	fi
	if [ "$UDP_PROBE" != '' ] ; then
		echo -n "Enabling probable probe logging [UDP]: "
		# IPv4
		$IPTABLES -A CUST_LOG -m multiport -p udp --dport $UDP_PROBE -j LOG --log-level $WARN_LOG_LEVEL \
			--log-ip-options --log-prefix "PROBE " || abortexit
		# IPv6
		$IP6TABLES -A CUST_LOG -m multiport -p udp --dport $UDP_PROBE -j LOG --log-level $WARN_LOG_LEVEL \
			--log-ip-options --log-prefix "PROBE " || abortexit
		if [ "$LOG_ALL_ELSE" = 'yes' ] ; then
			# IPv4
			$IPTABLES -A CUST_LOG -m multiport -p udp --dport $UDP_PROBE -j DROP || abortexit
			# IPv6
			$IP6TABLES -A CUST_LOG -m multiport -p udp --dport $UDP_PROBE -j DROP || abortexit
		fi
		echo -n "${B_WHITE}${UDP_PROBE}${NORMAL}"
		if [ "$UDP_PROBE2" != '' ] ; then
			# IPv4
			$IPTABLES -A CUST_LOG -m multiport -p tcp --dport $UDP_PROBE2 -j LOG \
				--log-level $WARN_LOG_LEVEL --log-ip-options --log-prefix "PROBE " || abortexit
			# IPv6
			$IP6TABLES -A CUST_LOG -m multiport -p tcp --dport $UDP_PROBE2 -j LOG \
				--log-level $WARN_LOG_LEVEL --log-ip-options --log-prefix "PROBE " || abortexit
			if [ "$LOG_ALL_ELSE" = 'yes' ] ; then
				# IPv4
				$IPTABLES -A CUST_LOG -m multiport -p tcp --dport $UDP_PROBE2 -j DROP || abortexit
				# IPv6
				$IP6TABLES -A CUST_LOG -m multiport -p tcp --dport $UDP_PROBE2 -j DROP || abortexit
			fi
			echo -n "${B_WHITE},${UDP_PROBE2}${NORMAL}"
		fi
		echo
	fi
fi

if [[ "$LOG_DROPS" == 'yes' && "$LOG_INVALID" == 'yes' ]] ; then
	echo "Enabling INVALID state logging"
	# IPv4
	$IPTABLES -A CUST_LOG -m state --state INVALID -j LOG --log-level $WARN_LOG_LEVEL \
		--log-prefix "INVALID " --log-ip-options --log-tcp-options || abortexit
	# IPv6
	$IP6TABLES -A CUST_LOG -m state --state INVALID -j LOG --log-level $WARN_LOG_LEVEL \
		--log-prefix "INVALID " --log-ip-options --log-tcp-options || abortexit
	if [ "$LOG_ALL_ELSE" = 'yes' ] ; then
		# IPv4
		$IPTABLES -A CUST_LOG -m state --state INVALID -j DROP || abortexit
		# IPv6
		$IP6TABLES -A CUST_LOG -m state --state INVALID -j DROP || abortexit
	fi
	# IPv4
	$IPTABLES -A CUST_LOG -m state --state NEW -p tcp ! --syn -j LOG --log-level $WARN_LOG_LEVEL \
		--log-prefix "INVALID " --log-ip-options --log-tcp-options || abortexit
	# IPv6
	$IP6TABLES -A CUST_LOG -m state --state NEW -p tcp ! --syn -j LOG --log-level $WARN_LOG_LEVEL \
		--log-prefix "INVALID " --log-ip-options --log-tcp-options || abortexit
	if [ "$LOG_ALL_ELSE" = 'yes' ] ; then
		# IPv4
		$IPTABLES -A CUST_LOG -m state --state NEW -p tcp ! --syn -j DROP || abortexit
		# IPv6
		$IP6TABLES -A CUST_LOG -m state --state NEW -p tcp ! --syn -j DROP || abortexit
	fi
fi

if [[ "$LOG_DROPS" == 'yes' && "$LOG_ICMP" == 'yes' ]] ; then
	echo "Enabling ICMP protocol logging"
	# IPv4
	$IPTABLES -A CUST_LOG -p icmp -j LOG --log-level $NORM_LOG_LEVEL --log-prefix "ICMP: " \
		--log-ip-options || abortexit
	# IPv6
	$IP6TABLES -A CUST_LOG -p icmpv6 -j LOG --log-level $NORM_LOG_LEVEL --log-prefix "ICMPV6: " \
		--log-ip-options || abortexit
	if [ "$LOG_ALL_ELSE" = 'yes' ] ; then
		# IPv4
		$IPTABLES -A CUST_LOG -p icmp -j DROP || abortexit
		# IPv6
		$IP6TABLES -A CUST_LOG -p icmpv6 -j DROP || abortexit
	fi
fi

if [[ "$LOG_DROPS" == 'yes' && "$LOG_SMB" == 'no' ]] ; then
	echo "Disabling SMB/CIFS logging"
	# IPv4
	$IPTABLES -A CUST_LOG -m multiport -p tcp --dport netbios-ssn,microsoft-ds -j DROP || abortexit
	$IPTABLES -A CUST_LOG -m multiport -p udp --dport netbios-ns,netbios-dgm -j DROP || abortexit
	# IPv6
	$IP6TABLES -A CUST_LOG -m multiport -p tcp --dport netbios-ssn,microsoft-ds -j DROP || abortexit
	$IP6TABLES -A CUST_LOG -m multiport -p udp --dport netbios-ns,netbios-dgm -j DROP || abortexit
fi
if [[ "$LOG_DROPS" == 'yes' && "$LOG_SMB" == 'yes' ]] ; then
	echo "Enabling SMB/CIFS logging"
	# IPv4
	$IPTABLES -A CUST_LOG -m multiport -p tcp --dport netbios-ssn,microsoft-ds -j LOG --log-level \
		$NORM_LOG_LEVEL --log-prefix "SMB: " --log-ip-options || abortexit
	$IPTABLES -A CUST_LOG -m multiport -p udp --dport netbios-ns,netbios-dgm -j LOG --log-level \
		$NORM_LOG_LEVEL --log-prefix "SMB: " --log-ip-options || abortexit
	# IPv6
	$IP6TABLES -A CUST_LOG -m multiport -p tcp --dport netbios-ssn,microsoft-ds -j LOG --log-level \
		$NORM_LOG_LEVEL --log-prefix "SMB: " --log-ip-options || abortexit
	$IP6TABLES -A CUST_LOG -m multiport -p udp --dport netbios-ns,netbios-dgm -j LOG --log-level \
		$NORM_LOG_LEVEL --log-prefix "SMB: " --log-ip-options || abortexit
	if [ "$LOG_ALL_ELSE" = 'yes' ] ; then
		# IPv4
		$IPTABLES -A CUST_LOG -m multiport -p tcp --dport netbios-ssn,microsoft-ds -j DROP || abortexit
		$IPTABLES -A CUST_LOG -m multiport -p udp --dport netbios-ns,netbios-dgm -j DROP || abortexit
		# IPv6
		$IP6TABLES -A CUST_LOG -m multiport -p tcp --dport netbios-ssn,microsoft-ds -j DROP || abortexit
		$IP6TABLES -A CUST_LOG -m multiport -p udp --dport netbios-ns,netbios-dgm -j DROP || abortexit
	fi
fi

if [[ "$CHECK_SYN_PACKET_LENGTH" == 'yes' ]] && \
	[[ "$LOG_DROPS" == 'yes' ]] && [[ "$LOG_PACKET_LENGTH" == 'yes' ]] ; then
	echo "Enabling illegal SYN packet length logging"
	# IPv4
	$IPTABLES -A CUST_LOG -p tcp -m length ! --length $PACKET_LENGTH -j LOG --log-level $WARN_LOG_LEVEL \
		--log-prefix "PACKET_LENGTH_BAD: " --log-ip-options --log-tcp-options || abortexit
	# IPv6
	$IP6TABLES -A CUST_LOG -p tcp -m length ! --length $PACKET_LENGTH -j LOG --log-level $WARN_LOG_LEVEL \
		--log-prefix "PACKET_LENGTH_BAD: " --log-ip-options --log-tcp-options || abortexit
	if [ "$LOG_ALL_ELSE" = 'yes' ] ; then
		# IPv4
		$IPTABLES -A CUST_LOG -p tcp -m length ! --length $PACKET_LENGTH -j DROP || abortexit
		# IPv6
		$IP6TABLES -A CUST_LOG -p tcp -m length ! --length $PACKET_LENGTH -j DROP || abortexit
	fi
fi

if [[ "$ENABLE_IPLIMIT" == 'yes' && "$LOG_DROPS" == 'yes' && "$LOG_IPLIMIT_EXCEED" == 'yes' ]] ; then
	echo "Enabling IP connection limit exceeded logging"
	# IPv4
	$IPTABLES -A CUST_LOG -p tcp -m ${CONNMODULE##*_} --${CONNMODULE##*_}-above $IPLIMIT_MAX_ACCEPT \
		--${CONNMODULE##*_}-mask $IPLIMIT_NETMASK -j LOG --log-level $WARN_LOG_LEVEL \
		--log-prefix "IPLIMIT_EXCEED: " --log-ip-options \
		--log-tcp-options || abortexit
	# IPv6
	$IP6TABLES -A CUST_LOG -p tcp -m ${CONNMODULE##*_} --${CONNMODULE##*_}-above $IPLIMIT_MAX_ACCEPT \
		--${CONNMODULE##*_}-mask $IPLIMIT_NETMASK -j LOG --log-level $WARN_LOG_LEVEL \
		--log-prefix "IPLIMIT_EXCEED: " --log-ip-options \
		--log-tcp-options || abortexit
	if [ "$LOG_ALL_ELSE" = 'yes' ] ; then
		# IPv4
		$IPTABLES -A CUST_LOG -p tcp -m ${CONNMODULE##*_} --${CONNMODULE##*_}-above $IPLIMIT_MAX_ACCEPT \
			--${CONNMODULE##*_}-mask $IPLIMIT_NETMASK -j DROP || abortexit
		# IPv6
		$IP6TABLES -A CUST_LOG -p tcp -m ${CONNMODULE##*_} --${CONNMODULE##*_}-above $IPLIMIT_MAX_ACCEPT \
			--${CONNMODULE##*_}-mask $IPLIMIT_NETMASK -j DROP || abortexit
	fi
fi

# Log connections that exceed the defined rate
if [[ "$ENABLE_LIMIT_RATE" == 'yes' && "$LOG_DROPS" == 'yes' && "$LOG_LIMIT_EXCEED" == 'yes' ]] ; then
	echo "Enalbing rate limit exceeded logging"
#	$IPTABLES -A CUST_LOG -p tcp -m limit ! --limit $LIMIT_RATE --limit-burst $LIMIT_BURST \
#	-j LOG --log-level $WARN_LOG_LEVEL --log-prefix "LIMIT_EXCEED: " --log-ip-options \
#	--log-tcp-options || abortexit
	# IPv4
	$IPTABLES -A CUST_LOG -p tcp -m limit --limit $LIMIT_RATE --limit-burst $LIMIT_BURST \
		-j LOG --log-level $WARN_LOG_LEVEL --log-prefix "LIMIT_EXCEED: " --log-ip-options \
		--log-tcp-options || abortexit
	# IPv6
	$IP6TABLES -A CUST_LOG -p tcp -m limit --limit $LIMIT_RATE --limit-burst $LIMIT_BURST \
		-j LOG --log-level $WARN_LOG_LEVEL --log-prefix "LIMIT_EXCEED: " --log-ip-options \
		--log-tcp-options || abortexit
	if [ "$LOG_ALL_ELSE" = 'yes' ] ; then
#		$IPTABLES -A CUST_LOG -p tcp -m limit ! --limit $LIMIT_RATE --limit-burst $LIMIT_BURST \
#		-j DROP || abortexit
		# IPv4
		$IPTABLES -A CUST_LOG -p tcp -m limit --limit $LIMIT_RATE --limit-burst $LIMIT_BURST \
			-j DROP || abortexit
		# IPv6
		$IP6TABLES -A CUST_LOG -p tcp -m limit --limit $LIMIT_RATE --limit-burst $LIMIT_BURST \
			-j DROP || abortexit
	fi
fi

# Just in case we missed anything
if [[ "$LOG_DROPS" == 'yes' && "$LOG_ALL_ELSE" == 'yes' ]] ; then
	echo "Enabling logging for all other dropped packets"
	# IPv4
	$IPTABLES -A CUST_LOG -j LOG --log-level $NORM_LOG_LEVEL --log-ip-options --log-tcp-options \
		--log-prefix "ALL_ELSE " || abortexit
	$IPTABLES -A CUST_LOG -j DROP || abortexit
	# IPv6
	$IP6TABLES -A CUST_LOG -j LOG --log-level $NORM_LOG_LEVEL --log-ip-options --log-tcp-options \
		--log-prefix "ALL_ELSE " || abortexit
	$IP6TABLES -A CUST_LOG -j DROP || abortexit
fi
if [[ "$LOG_DROPS" == 'yes' && "$LOG_ALL_ELSE" == 'no' ]] ; then
	echo "Default (non-explicit) drops not logged"
	# IPv4
	$IPTABLES -A CUST_LOG -j DROP || abortexit
	# IPv6
	$IP6TABLES -A CUST_LOG -j DROP || abortexit
fi

if [ "$LOG_DROPS" != 'yes' ] ; then
	echo "Logging is disabled!"
fi

##
## Chain checking order
##

# IPv4 INPUT
$IPTABLES -A INPUT -j SPOOF_CHK || abortexit
$IPTABLES -A INPUT -p tcp -j SANITY_CHK || abortexit
$IPTABLES -A INPUT -j STATE_CHK || abortexit
$IPTABLES -A INPUT -p tcp -j TCP_CHK || abortexit
$IPTABLES -A INPUT -p udp -j UDP_CHK || abortexit
$IPTABLES -A INPUT -p icmp -j ICMP_CHK || abortexit

# IPv6 INPUT
$IP6TABLES -A INPUT -j RH_CHK || abortexit
$IP6TABLES -A INPUT -j SPOOF_CHK || abortexit
$IP6TABLES -A INPUT -p tcp -j SANITY_CHK || abortexit
$IP6TABLES -A INPUT -j STATE_CHK || abortexit
$IP6TABLES -A INPUT -p tcp -j TCP_CHK || abortexit
$IP6TABLES -A INPUT -p udp -j UDP_CHK || abortexit
$IP6TABLES -A INPUT -p icmpv6 -j ICMP_CHK || abortexit

# IPv6 OUTPUT
$IP6TABLES -A OUTPUT -j RH_CHK || abortexit
$IP6TABLES -A OUTPUT -p icmpv6 -j ICMP_CHK || abortexit

# Accept loopback traffic
# #######################
# TODO: normal prüfen (::1/64)
# #######################
if [ "$LOOPBACK_ACCEPT" = 'yes' ] ; then
	case "$LOOPBACK_MODE" in
		"paranoid" )
			# IPv4
			$IPTABLES -I INPUT 4 -m state --state NEW -s 127.0.0.1 -d 127.0.0.1 -i lo \
				-j ACCEPT || abortexit
			# IPv6
			$IP6TABLES -I INPUT 4 -m state --state NEW -s ::1/128 -d ::1/128 -i lo \
				-j ACCEPT || abortexit
			;;
		"normal" )
			# IPv4
		    $IPTABLES -I INPUT 4 -m state --state NEW -s 127.0.0.1/24 -d 127.0.0.1/24 -i lo \
		    	-j ACCEPT || abortexit
			# IPv6
		    $IP6TABLES -I INPUT 4 -m state --state NEW -s ::1/64 -d ::1/64 -i lo \
		    	-j ACCEPT || abortexit
			;;
		"loose" )
			# IPv4
			$IPTABLES -I INPUT 4 -m state --state NEW -i lo -j ACCEPT || abortexit
			# IPv6
			$IP6TABLES -I INPUT 4 -m state --state NEW -i lo -j ACCEPT || abortexit
			;;
		* )
			echo $RED"Conf error:$NORMAL Check ${B_WHITE}LOOPBACK_MODE$NORMAL"
			confexit
			;;
	esac
fi

##
## Masqürade networks
##

# NAT section
if [ "$MASQUERADE" = 'yes' ] ; then
	echo -n "Enabling IP forwarding: "
	echo "1" >/proc/sys/net/ipv4/ip_forward && \
	echo "1" >/proc/sys/net/ipv6/conf/all/forwarding && \
	echo "1" >/proc/sys/net/ipv6/conf/default/forwarding && echo $RCOK || echo $RCFAIL
	if [ "$LOAD_MODULES" = 'yes' ] ; then
		echo -n "Enabling network masqürading: "
		for module in ${=NAT_MODULES} ; {
			if ! grep $module ${TMPDIR}/kwnarc.tmp > /dev/null 2>&1 ; then
				/sbin/modprobe $module && echo -n "[ ${B_WHITE}${module}${NORMAL} - $RCOK ] " || echo -n \
				"[ ${B_WHITE}${module}${NORMAL} - $RCFAIL ] "
			fi
		}
		echo
	else
		echo "Enabling network masqürading"
	fi
	# IPv4
	$IPTABLES -t nat -F POSTROUTING || abortexit
	# IPv6
	$IP6TABLES -t nat -F POSTROUTING || abortexit
	$IP6TABLES -t nat -A POSTROUTING -o $EXTERNAL_INTERFACE \
		-j SNAT --to $EXTERNAL_INTERFACE_IPV6 || abortexit
	# only IPv4
	if [ "$DYNAMIC_EXTERNAL_IP" = 'no' ] ; then
		$IPTABLES -t nat -A POSTROUTING -o $EXTERNAL_INTERFACE \
			-j SNAT --to $EXTERNAL_INTERFACE_IP || abortexit
	else
		$IPTABLES -t nat -A POSTROUTING -o $EXTERNAL_INTERFACE -j MASQUERADE || abortexit
	fi
fi

# Add forwarding rules
if [ "$MASQUERADE" = 'yes' ] ; then
	# IPv4
	$IPTABLES -A FORWARD -j SPOOF_CHK || abortexit
	$IPTABLES -A FORWARD -p tcp -i $EXTERNAL_INTERFACE -j SANITY_CHK || abortexit
	$IPTABLES -A FORWARD -j STATE_CHK || abortexit
	# IPv6
	$IP6TABLES -A FORWARD -j RH_CHK || abortexit
	$IP6TABLES -A FORWARD -j SPOOF_CHK || abortexit
	$IP6TABLES -A FORWARD -p tcp -i $EXTERNAL_INTERFACE -j SANITY_CHK || abortexit
	$IP6TABLES -A FORWARD -j STATE_CHK || abortexit
	if [ "$LAN_INTERFACE" != '' ] ; then
		if [ "$PROTECT_FROM_LAN" = 'yes' ] ; then
			# IPv4
			$IPTABLES -A FORWARD -m state --state NEW -i $LAN_INTERFACE -o $EXTERNAL_INTERFACE \
				-j ACCEPT || abortexit
			# IPv6
			$IP6TABLES -A FORWARD -m state --state NEW -i $LAN_INTERFACE -o $EXTERNAL_INTERFACE \
				-j ACCEPT || abortexit
		fi
	fi
	if [ "$DMZ_INTERFACE" != '' ] ; then
		if [ "$PROTECT_FROM_DMZ" = 'yes' ] ; then
			# IPv4
			$IPTABLES -A FORWARD -m state --state NEW -i $DMZ_INTERFACE -o $EXTERNAL_INTERFACE \
				-j ACCEPT || abortexit
			# IPv6
			$IP6TABLES -A FORWARD -m state --state NEW -i $DMZ_INTERFACE -o $EXTERNAL_INTERFACE \
				-j ACCEPT || abortexit
		fi
	fi
	if [ "$FORWARD_LAN_TO_DMZ" = 'yes' ] ; then
		if [[ "$LAN_INTERFACE" != '' && "$DMZ_INTERFACE" != '' ]] ; then
			# IPv4
			$IPTABLES -A FORWARD -m state --state NEW -i $LAN_INTERFACE -o $DMZ_INTERFACE \
				-j ACCEPT || abortexit
			# IPv6
			$IP6TABLES -A FORWARD -m state --state NEW -i $LAN_INTERFACE -o $DMZ_INTERFACE \
				-j ACCEPT || abortexit
		fi
	fi
	if [ "$FORWARD_DMZ_TO_LAN" = 'yes' ] ; then
		if [[ "$LAN_INTERFACE" != '' && "$DMZ_INTERFACE" != '' ]] ; then
			# IPv4
			$IPTABLES -A FORWARD -m state --state NEW -i $DMZ_INTERFACE -o $LAN_INTERFACE \
				-j ACCEPT || abortexit
			# IPv6
			$IP6TABLES -A FORWARD -m state --state NEW -i $DMZ_INTERFACE -o $LAN_INTERFACE \
				-j ACCEPT || abortexit
		fi
	fi
else
	if [ "$ALWAYS_FORWARD" = 'yes' ] ; then
		echo -n "Enabling IP forwarding: "
		echo "1" >/proc/sys/net/ipv4/ip_forward && \
		echo "1" >/proc/sys/net/ipv6/conf/all/forwarding && \
		echo "1" >/proc/sys/net/ipv6/conf/default/forwarding && echo $RCOK || echo $RCFAIL
		# IPv4
		$IPTABLES -A FORWARD -j SPOOF_CHK || abortexit
		$IPTABLES -A FORWARD -p tcp -i $EXTERNAL_INTERFACE -j SANITY_CHK || abortexit
		$IPTABLES -A FORWARD -j STATE_CHK || abortexit
		# IPv6
		$IP6TABLES -A FORWARD -j RH_CHK || abortexit
		$IP6TABLES -A FORWARD -j SPOOF_CHK || abortexit
		$IP6TABLES -A FORWARD -p tcp -i $EXTERNAL_INTERFACE -j SANITY_CHK || abortexit
		$IP6TABLES -A FORWARD -j STATE_CHK || abortexit
		if [ "$LAN_INTERFACE" != '' ] ; then
			if [ "$PROTECT_FROM_LAN" = 'yes' ] ; then
				# IPv4
				$IPTABLES -A FORWARD -m state --state NEW -i $LAN_INTERFACE \
					-o $EXTERNAL_INTERFACE -j ACCEPT || abortexit
				# IPv6
				$IP6TABLES -A FORWARD -m state --state NEW -i $LAN_INTERFACE \
					-o $EXTERNAL_INTERFACE -j ACCEPT || abortexit
		    fi
		fi
		if [ "$DMZ_INTERFACE" != '' ] ; then
			if [ "$PROTECT_FROM_DMZ" = 'yes' ] ; then
				# IPv4
				$IPTABLES -A FORWARD -m state --state NEW -i $DMZ_INTERFACE \
					-o $EXTERNAL_INTERFACE -j ACCEPT || abortexit
				# IPv6
				$IP6TABLES -A FORWARD -m state --state NEW -i $DMZ_INTERFACE \
					-o $EXTERNAL_INTERFACE -j ACCEPT || abortexit
			fi
		fi
		if [ "$FORWARD_LAN_TO_DMZ" = 'yes' ] ; then
			if [[ "$LAN_INTERFACE" != '' && "$DMZ_INTERFACE" != '' ]] ; then
				# IPv4
				$IPTABLES -A FORWARD -m state --state NEW -i $LAN_INTERFACE \
					-o $DMZ_INTERFACE -j ACCEPT || abortexit
				# IPv6
				$IP6TABLES -A FORWARD -m state --state NEW -i $LAN_INTERFACE \
					-o $DMZ_INTERFACE -j ACCEPT || abortexit
			fi
		fi
		if [ "$FORWARD_DMZ_TO_LAN" = 'yes' ] ; then
			if [[ "$LAN_INTERFACE" != '' && "$DMZ_INTERFACE" != '' ]] ; then
				# IPv4
				$IPTABLES -A FORWARD -m state --state NEW -i $DMZ_INTERFACE -o $LAN_INTERFACE \
					-j ACCEPT || abortexit
				# IPv6
				$IP6TABLES -A FORWARD -m state --state NEW -i $DMZ_INTERFACE -o $LAN_INTERFACE \
					-j ACCEPT || abortexit
			fi
		fi
	fi
fi

##
## Port Forwarding
##

# IPv4
if [ "$PORT_FORWARD" = 'yes' ] ; then
	for var in `grep -v "^ *#" $FORWARD_CONF | grep -v '^$'` ; {
		INTERFACE=`echo $var | cut -d \" -f2`
		PROTOCOL=`echo $var | cut -d \" -f4`
		ORIG_IP=`echo $var | cut -d \" -f6`
		ORIG_PORT=`echo $var | cut -d \" -f8`
		NEW_IP=`echo $var | cut -d \" -f10`
		NEW_PORT=`echo $var | cut -d \" -f12`
		# default to the DMZ interface if INTERFACE is empty
		if [ "$INTERFACE" = '' ] ; then
			INTERFACE="$DMZ_INTERFACE"
		fi
		if [ "$ORIG_IP" = 'AUTOGET_EXTERNAL_IP' ] ; then
			ORIG_IP="$EXTERNAL_INTERFACE_IP"
		fi
		if [[ "$PROTOCOL" != '' && "$ORIG_IP" != '' && "$ORIG_PORT" != '' ]] && \
			[[ "$NEW_IP" != '' && "$NEW_PORT" != '' ]] ; then
			$IPTABLES -t nat -A PREROUTING -i $EXTERNAL_INTERFACE -p $PROTOCOL -d $ORIG_IP \
				--dport $ORIG_PORT -j DNAT --to $NEW_IP:$NEW_PORT || abortexit
			if [ "$PROTOCOL" = 'tcp' ] ; then
				$IPTABLES -A FORWARD -i $EXTERNAL_INTERFACE -o $INTERFACE -p $PROTOCOL -m state \
					--state NEW --syn -d $NEW_IP --dport $NEW_PORT -j ACCEPT || abortexit
			else
				$IPTABLES -A FORWARD -i $EXTERNAL_INTERFACE -o $INTERFACE -p $PROTOCOL -m state \
					--state NEW -d $NEW_IP --dport $NEW_PORT -j ACCEPT || abortexit
			fi
			echo "Forwarding ${B_WHITE}${PROTOCOL} ${ORIG_IP}:${ORIG_PORT}${NORMAL} to ${INTERFACE}:${B_WHITE}${NEW_IP}:${NEW_PORT}${NORMAL}"
			FWDSUCCESS='true'
		fi
	}
	if [ "$FWDSUCCESS" != 'true' ] ; then
		echo $RED"Conf error:$NORMAL No ports to forward.  Check ${B_WHITE}${FORWARD_CONF}${NORMAL} for errors."
		abortexit
	fi
fi

# IPv6
if [ "$PORT_FORWARD" = 'yes' ] ; then
	for var in `grep -v "^ *#" $FORWARD6_CONF | grep -v '^$'` ; {
		INTERFACE=`echo $var | cut -d \" -f2`
		PROTOCOL=`echo $var | cut -d \" -f4`
		ORIG_IP=`echo $var | cut -d \" -f6`
		ORIG_PORT=`echo $var | cut -d \" -f8`
		NEW_IP=`echo $var | cut -d \" -f10`
		NEW_PORT=`echo $var | cut -d \" -f12`
		# default to the DMZ interface if INTERFACE is empty
		if [ "$INTERFACE" = '' ] ; then
			INTERFACE="$DMZ_INTERFACE"
		fi
		if [ "$ORIG_IP" = 'AUTOGET_EXTERNAL_IPV6' ] ; then
			ORIG_IP="$EXTERNAL_INTERFACE_IPV6"
		fi
		if [[ "$PROTOCOL" != '' && "$ORIG_IP" != '' && "$ORIG_PORT" != '' ]] && \
			[[ "$NEW_IP" != '' && "$NEW_PORT" != '' ]] ; then
			$IP6TABLES -t nat -A PREROUTING -i $EXTERNAL_INTERFACE -p $PROTOCOL -d $ORIG_IP \
				--dport $ORIG_PORT -j DNAT --to $NEW_IP || abortexit
			if [ "$PROTOCOL" = 'tcp' ] ; then
				$IP6TABLES -A FORWARD -i $EXTERNAL_INTERFACE -o $INTERFACE -p $PROTOCOL -m state \
					--state NEW --syn -d $NEW_IP --dport $NEW_PORT -j ACCEPT || abortexit
			else
				$IP6TABLES -A FORWARD -i $EXTERNAL_INTERFACE -o $INTERFACE -p $PROTOCOL -m state \
					--state NEW -d $NEW_IP --dport $NEW_PORT -j ACCEPT || abortexit
			fi
			echo "Forwarding ${B_WHITE}${PROTOCOL} ${ORIG_IP}:${ORIG_PORT}${NORMAL} to ${INTERFACE}:${B_WHITE}${NEW_IP}:${NEW_PORT}${NORMAL}"
			FWDSUCCESS='true'
		fi
	}
	if [ "$FWDSUCCESS" != 'true' ] ; then
		echo $RED"Conf error:$NORMAL No ports to forward.  Check ${B_WHITE}${FORWARD_CONF}${NORMAL} for errors."
		abortexit
	fi
fi

##
## Execute custom script
##

if [ "$EXECUTE_CUSTOM_SCRIPT" = 'yes' ] ; then
	echo "Executing custom commands:"
	LINELENGTH=`grep -v "^ *#" $CUSTOM_SCRIPT | wc -L`
	if [ `expr $LINELENGTH \< 1` = 1 ] ; then
		echo $RED"Conf error:$NORMAL (non-fatal) No commands to execute in ${B_WHITE}${CUSTOM_SCRIPT}${NORMAL}"
	else
		grep -v "^ *#" $CUSTOM_SCRIPT | \
			( while read line ; do
			if [ "$line" != '' ] ; then
				eval $line && echo "${B_WHITE}${line}${NORMAL} - $RCOK" || \
					echo "${B_WHITE}${line}${NORMAL} - $RCFAIL"
			fi
			done )
		echo "Finished executing custom commands"
	fi
fi

# End
removetemp
echo $B_WHITE"Finished firewall (ip(6)tables) initialization$NORMAL"
### Modeline {{{
### vim:ft=zsh:foldmethod=marker
### vim:set ts=4:                                                                               
### }}}
