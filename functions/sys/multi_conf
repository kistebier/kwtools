# Funktion multi_conf# {{{
#
# usage: multi_conf
#
multi_conf() {
	# ###### Multimedia Funktionen ###### {{{
	#
	Unset=(CREATE_IMAGE_ONLY IMAGE APPID PUBLISHER PREPARER ON_THE_FLY_OPT
	SYSID SYMLINKS IS_MULTISESSION MULTISESSION WRITEMODE DATAMODE COPYNR)
	#
	# Variablen
	gv_Audio_Cd=$(gettext 'Audio-CD')
	gv_Audio_Dvd=$(gettext 'Audio-DVD')
	gv_Cdcopy=$(gettext 'CD-kopieren')
	gv_Dvdcopy=$(gettext 'DVD-kopieren')
	gv_Data_Cd=$(gettext 'Daten-CD')
	gv_Data_Dvd=$(gettext 'Daten-DVD')
	gv_Iso_Cd=$(gettext 'ISO-CD')
	gv_Iso_Dvd=$(gettext 'ISO-DVD')
	gv_Photo_Cd=$(gettext 'Photo-CD')
	gv_Photo_Dvd=$(gettext 'Photo-DVD')
	gv_Video_Cd=$(gettext 'Video-CD')
	gv_Video_Dvd=$(gettext 'Video-DVD')
	gv_Del_Cd=$(gettext 'CD-löschen')
	gv_Format_Dvd=$(gettext 'DVD-formatieren')
	#
	IST_FILE="${gv_WorkDir}/burn_auswahl"
	BURN_PROGRESS_TITLE=$(gettext 'Brennen')
	BURN_FINISH_PROGRESS_MSG=$(gettext 'Schliesse Multisession ab.')
	CD_DEL_TITLE=$(gettext 'CD+-RW::löschen')
	CD_DEL_MSG=$(gettext 'Lösche CD+-RW.')
	ISO_TITLE=$(gettext 'ISO Abbild')

	# Funktion (audio_burn), um Audio Datei zu brennen{{{
	#
	# Es werden nur Audio Dateien zum Brennen zur Verfügung gestellt.
	# Es gehen z.Z. nur wav,mp3 und ogg Dateien.
	#
	# usage: audio_burn [ CD | DVD ]
	audio_burn() {
		if [[ ${#argv} == 1 ]] ; then
			local Opt
			Opt="$1"
			BURN_TITLE=$(gettext 'Audio_brennen')
			BURN_MSG=$(gettext 'Wählen Sie ein Audio Format aus. Nur diese Dateien werden zum brennen angezeigt.')
			BURN_MENU=(ogg \"\" mp3 \"\" wav \"\" $gv_Back \"\")
			case "$Opt" in
				CD)
					menubox "" "$BURN_TITLE" "$BURN_MSG" "$BURN_MENU"
					while [ "$gv_Auswahl" ] ; do
						case $gv_Auswahl in
							HELP*)	script_help share/audio_help
								menubox "${gv_Auswahl#HELP }" "$BURN_TITLE" "$BURN_MSG" "$BURN_MENU"
								;;
							o*)	# Ogg Vorbis Sounddateien brennen
								cd_dvd_burn --oggcd
								;;
							m*)	# MP3 Sounddateien brennen
								cd_dvd_burn --mp3cd
								;;
							w*)	# WAV Sounddateien brennen
								cd_dvd_burn --wavcd
								;;
							$gv_Back) break
								;;
						esac
					done
					;;
				DVD)
					menubox "" "$BURN_TITLE" "$BURN_MSG" "$BURN_MENU"
					while [ "$gv_Auswahl" ] ; do
						case $gv_Auswahl in
							HELP*)	script_help share/audio_help
								menubox "${gv_Auswahl#HELP }" "$BURN_TITLE" "$BURN_MSG" "$BURN_MENU"
								;;
							o*)	# Ogg Vorbis Sounddateien brennen
								cd_dvd_burn --oggdvd
								break
								;;
							m*)	# MP3 Sounddateien brennen
								cd_dvd_burn --mp3dvd
								break
								;;
							w*)	# WAV Sounddateien brennen
								cd_dvd_burn --wavdvd
								break
								;;
							$gv_Back) break 
								;;
						esac
					done
					;;
				*)
					# falscher Parameter
					wrong_parameter_msg "$0"
					;;
			esac
		else
			no_para_msg $0
		fi
	}
	#}}}
	# Funktion (burn_opt), mkisofs und andere Brennoptionen# {{{
	#
	# usage: burn_opt
	#
	burn_opt() {
		# Translation Variablen# {{{
		lv_Source_Dev=$(gettext 'Leselaufwerk')
		lv_Burn_Dev=$(gettext 'Brennlaufwerk')
		lv_Copynr=$(gettext 'Kopienanzahl')
		lv_Volid=$(gettext 'Volume Name')
		lv_Appid=$(gettext 'Programm')
		lv_Publisher=$(gettext 'Veröffentlicher')
		lv_Preparer=$(gettext 'Vorbereiter')
		lv_WriteMode=$(gettext 'Schreib-Modus')
		lv_CreateImageOnly=$(gettext 'nur Image erstellen')
		lv_Image=$(gettext 'Abbild')
		lv_Create_Image=$(gettext 'Abbild erstellen')
		lv_Create_Only_Image=$(gettext 'nur Abbild erstellen')
		lv_Del_Image=$(gettext 'Abbild löschen')
		lv_Sysid=$(gettext 'Dateisystem')
		lv_Symlinks=$(gettext 'symbolische Links')
		lv_Simulate=$(gettext 'simulieren')
		lv_DatatrackMode=$(gettext 'Datentrack-Modus')
		lv_Multisession=$(gettext 'Multisession')
		lv_Auto=$(gettext 'auto')
		lv_No_Multisession=$(gettext 'keine Multisession')
		lv_Start_Multisession=$(gettext 'Multisession starten')
		lv_Continue_Multisession=$(gettext 'Multisession fortsetzen')
		lv_Finish_Multisession=$(gettext 'Multisession beenden')
		lv_Burn=$(gettext 'brennen')
		lv_Burn_Opt=$(gettext 'Brennoptionen')
		lv_SL_None=$(gettext 'keine Änderung')
		lv_SL_Discard_Broken=$(gettext 'Ungültige symbolische Verknüpfungen verwerfen')
		lv_SL_Discard_All=$(gettext 'Alle symbolischen Verknüpfungen verwerfen')
		lv_SL_Follow=$(gettext 'symbolischen Verknüpfungen folgen')
		#
		BURN_OPT_MSG=$(gettext 'Wenn die Konfiguration in Ordnung ist wählen Sie den Menüpunkt \"brennen\" aus, ansonsten ändern Sie vorher Ihre Einstellungen.')
		## }}}
		# Variablen vorbelegen.# {{{
		if [ -z "$APPID" ] ; then
		    Now_Year=$(date +%Y)
		    APPID="$gv_ScriptName, $gv_Firm Netzworkk - $gv_MyName (C) 2002-$Now_Year"
		fi
		if [ -z "$SIMULATE" ] ; then
		    SIMULATE="no"
		fi
		if [ -z "$SYSID" ] ; then
		    SYSID="LINUX/UNIX"
		fi
		SYMLINKS="$lv_SL_None"
	    DATAMODE="auto"
	    MULTISESSION="auto"
		COPYNR="1"
		## }}}
		# Funktion burn_opt_menu# {{{
		#
		burn_opt_menu() {
			case "$PROJECT_TITLE" in
				$gv_Audio_Cd)
			   		BURN_OPT_MENU=($lv_Burn_Dev \"$WRITE_DEVICE\" $lv_Copynr \"$COPYNR\"
				    \"$lv_Volid\" \"$VOLID\" $lv_Appid \"$APPID\" 
				    $lv_Publisher \"$PUBLISHER\"
					$lv_Preparer \"$PREPARER\"
					$lv_Simulate \"$SIMULATE\"
				    $lv_Multisession \"$MULTISESSION\"
			    	$lv_Burn \"\" $gv_Back \"\")
					;;
				$gv_Cdcopy|$gv_Dvdcopy)
					if [[ ${#STL_CD_DEV} -gt 1 ]] ; then
						BURN_OPT_MENU=($lv_Source_Dev \"$READ_DEVICE\"
						$lv_Burn_Dev \"$WRITE_DEVICE\"
						$lv_Copynr \"$COPYNR\"
						$lv_Simulate \"$SIMULATE\"
					 	$lv_Image \"$IMAGE\"
						$lv_Burn \"\" $gv_Back \"\")
					else
						BURN_OPT_MENU=($lv_Copynr \"$COPYNR\"
						$lv_Simulate \"$SIMULATE\"
					 	$lv_Image \"$IMAGE\"
						$lv_Burn \"\" $gv_Back \"\")
					fi
					;;
				$gv_Video_Cd)
			   		BURN_OPT_MENU=($lv_Burn_Dev \"$WRITE_DEVICE\" $lv_Copynr \"$COPYNR\"
					$lv_Simulate \"$SIMULATE\"
			    	$lv_Burn \"\" $gv_Back \"\")
					;;
				$gv_Video_Dvd)
					BURN_OPT_MENU=($lv_Burn_Dev \"$WRITE_DEVICE\" $lv_Copynr \"$COPYNR\"
				    \"$lv_Volid\" \"$VOLID\" $lv_Appid \"$APPID\" 
				    $lv_Publisher \"$PUBLISHER\"
					$lv_Preparer \"$PREPARER\"
					$lv_Simulate \"$SIMULATE\"
				 	$lv_Image \"$IMAGE\"
				    $lv_Sysid \"$SYSID\"
					$lv_Burn \"\" $gv_Back \"\")
					;;
				$gv_Iso_Cd)
			   		BURN_OPT_MENU=($lv_Burn_Dev \"$WRITE_DEVICE\" $lv_Copynr \"$COPYNR\"
					$lv_Simulate \"$SIMULATE\"
			    	$lv_DatatrackMode \"$DATAMODE\"
			    	$lv_Burn \"\" $gv_Back \"\")
					;;
				$gv_Iso_Dvd)
			   		BURN_OPT_MENU=($lv_Burn_Dev \"$WRITE_DEVICE\" $lv_Copynr \"$COPYNR\"
					$lv_Simulate \"$SIMULATE\"
				    $lv_Multisession \"$MULTISESSION\"
			    	$lv_Burn \"\" $gv_Back \"\")
					;;
				$gv_Data_Cd|$gv_Photo_Cd)
				    BURN_OPT_MENU=($lv_Burn_Dev \"$WRITE_DEVICE\" $lv_Copynr \"$COPYNR\"
				    \"$lv_Volid\" \"$VOLID\" $lv_Appid \"$APPID\" 
				    $lv_Publisher \"$PUBLISHER\"
					$lv_Preparer \"$PREPARER\"
					$lv_Simulate \"$SIMULATE\"
				    $lv_Image \"$IMAGE\"
				    $lv_Sysid \"$SYSID\"
					\"$lv_Symlinks\" \"$SYMLINKS\"
				    $lv_DatatrackMode \"$DATAMODE\"
				    $lv_Multisession \"$MULTISESSION\"
				    $lv_Burn \"\" $gv_Back \"\")
					;;
				$gv_Data_Dvd|$gv_Photo_Dvd|$gv_Audio_Dvd)
				    BURN_OPT_MENU=($lv_Burn_Dev \"$WRITE_DEVICE\" $lv_Copynr \"$COPYNR\"
				    \"$lv_Volid\" \"$VOLID\" $lv_Appid \"$APPID\" 
				    $lv_Publisher \"$PUBLISHER\"
					$lv_Preparer \"$PREPARER\"
					$lv_Simulate \"$SIMULATE\"
				    $lv_Image \"$IMAGE\"
				    $lv_Sysid \"$SYSID\"
					\"$lv_Symlinks\" \"$SYMLINKS\"
				    $lv_Multisession \"$MULTISESSION\"
				    $lv_Burn \"\" $gv_Back \"\")
					;;
			esac
			BREAK=1
			menubox "$1" "$PROJECT_TITLE" "$BURN_OPT_MSG" "$BURN_OPT_MENU"
		}
		## }}}
		burn_opt_menu
		while [ "$gv_Auswahl" ] ; do
			case $gv_Auswahl in
				HELP*)
		    	    # Hilfe Messagebox
					script_help share/burn_opt_help
					burn_opt_menu "${gv_Auswahl#HELP }"
					;;
				$lv_Source_Dev)
					# Auswahl des Quell Laufwerks
					cd_dvd_device
					# Wenn kein Quell-Laufwerk Laufwerk vorhanden ist abbrechen
					if [ -n "$DEVICE" ] ; then
						READ_DEVICE="$DEVICE"
					fi
					#
					burn_opt_menu $lv_Source_Dev
					;;
				$lv_Burn_Dev)
					# Auswahl des Brenn Laufwerks
					cd_dvd_device
					# Wenn kein Brenn Laufwerk vorhanden ist abbrechen
					if [ -n "$DEVICE" ] ; then
						WRITE_DEVICE="$DEVICE"
					fi
					#
					burn_opt_menu $lv_Burn_Dev
					;;
				$lv_Copynr)
					# Anzahl der Kopien# {{{
		            COPYNR_MSG=$(gettext 'Geben Sie bitte die Anzahl der Kopien an.')
		            number_input -i "$PROJECT_TITLE" "$COPYNR_MSG" "$COPYNR"
		            if [ "$NUMBER" -gt 1 ] ; then
		                COPYNR="$NUMBER"
						CREATE_IMAGE_ONLY=no
		            else
		                COPYNR="1"
		            fi
		            ## }}}
					burn_opt_menu $lv_Copynr
					;;
				$lv_Volid)
		            # Volume ID eingeben# {{{
		            VOLID_MSG=$(gettext 'Geben Sie bitte einen Namen für den Index an.')
		            inputbox "$PROJECT_TITLE" "$VOLID_MSG" "$VOLID"
		            if [ -n "$gv_Auswahl" ] ; then
		                VOLID="$gv_Auswahl"
		            else
		                VOLID="none"
		            fi
		            ## }}}
					burn_opt_menu $lv_Volid
					;;
				$lv_Appid)
		            # Programm eingeben mit dem alles erstellt bzw. gebrannt wird.# {{{
		            APPID_MSG=$(gettext 'Geben Sie bitte einen Namen für das verwendete Programm ein.')
		            inputbox "$PROJECT_TITLE" "$APPID_MSG" "$APPID"
		            if [ -n "$gv_Auswahl" ] ; then
		                APPID="$gv_Auswahl"
		            else
		                APPID=""
		            fi
		            ## }}}
					burn_opt_menu $lv_Appid
					;;
				$lv_Publisher)
		            # Publisher eingeben# {{{
		            PUBLISHER_MSG=$(gettext 'Geben Sie bitte einen Namen für den Veröffentlicher ein.')
		            inputbox "$PROJECT_TITLE" "$PUBLISHER_MSG" "$PUBLISHER"
		            if [ -n "$gv_Auswahl" ] ; then
		                PUBLISHER="$gv_Auswahl"
		            else
		                PUBLISHER=""
		            fi
		            ## }}}
					burn_opt_menu $lv_Publisher
					;;
				$lv_Preparer)
		            # Vorbereiter eingeben# {{{
		            PREPARER_MSG=$(gettext 'Geben Sie bitte einen Namen für den Vorbereiter ein.')
		            inputbox "$PROJECT_TITLE" "$PREPARER_MSG" "$PREPARER"
		            if [ -n "$gv_Auswahl" ] ; then
		                PREPARER="$gv_Auswahl"
		            else
		                PREPARER=""
		            fi
		            ## }}}
					burn_opt_menu $lv_Preparer
					;;
				$lv_Simulate)
					# CD/DVD on the fly kopieren (yes/no)?{{{
					SIMULATE_MSG=$(gettext 'Soll das brennen simuliert werden (${gv_Yes}/${gv_No})?')
					yesno "$PROJECT_TITLE" "$SIMULATE_MSG" "$SIMULATE"
					if [ "$gv_Auswahl" = yes ] ; then
						SIMULATE=yes
					else
						SIMULATE=no
					fi
					#}}}
					burn_opt_menu $lv_Simulate
					;;
				$lv_WriteMode)
		            # Schreib-Modus auswählen# {{{
		            WRITE_MODE_MENU=(auto \"\" DAO \"\" TAO \"\" RAW \"\")
		            WRITE_MODE_MSG=$(gettext 'Wählen Sie Ihren Modus zum schreiben der Daten aus.')
			        menubox "$WRITEMODE" "$PROJECT_TITLE" "$WRITE_MODE_MSG" "$WRITE_MODE_MENU"
					while [ "$gv_Auswahl" ] ; do
						case $gv_Auswahl in
							HELP*)
					    	    # Hilfe Messagebox
								script_help share/burn_opt_help
			        			menubox "${gv_Auswahl#HELP }" "$PROJECT_TITLE" "$WRITE_MODE_MSG" "$WRITE_MODE_MENU"
								;;
		                    *)
								# Auswahl übernehmen
								WRITEMODE="$gv_Auswahl"
								break
		                        ;;
		                esac
		            done
					# falls die Var. WRITEMODE leer ist mit dem Wert "auto"
					# belegen.
					WRITEMODE="${WRITEMODE:-auto}"
					## }}}
					burn_opt_menu $lv_WriteMode
					;;
				$lv_Image)
					# Image (nur) erstellen/löschen# {{{
					#
					generate_is_file "$IMAGE"
					is_value "create only delete"
					#
					# Funktion (image_menu)# {{{
					image_menu() {
						IMAGE_MSG=$(gettext 'Wählen Sie einen oder mehrere Optionen aus.')
			        	checklist "$1" "$PROJECT_TITLE" "$IMAGE_MSG" "$VALUE_ARRAY" "$IMAGE"
					}
					## }}}
					image_menu "${VALUE_ARRAY[1]}"
					while [ -n "$gv_Auswahl" ] ; do
						case "$gv_Auswahl" in
							HELP*) # Hilfe
								script_help share/burn_opt_image_help
								image_menu "${gv_Auswahl#HELP }"
								;;
							*)
								IMAGE="$gv_Auswahl_Display"
								break
								;;
						esac
					done
					## }}}
					burn_opt_menu $lv_Image
					;;
				$lv_Sysid)
		            # Dateissystem einstellen# {{{
		            SYSID_MENU=(LINUX/UNIX \"\" LINUX/UNIX+WINDOWS \"\"
				   	DOS \"\" UDF \"\")
		            SYSID_MSG=$(gettext 'Wählen Sie ein Dateisystem aus.')
			        menubox "$SYSID" "$PROJECT_TITLE" "$SYSID_MSG" "$SYSID_MENU"
					while [ "$gv_Auswahl" ] ; do
						case $gv_Auswahl in
							HELP*)
					    	    # Hilfe Messagebox
								script_help share/burn_opt_sysid_help
			        			menubox "${gv_Auswahl#HELP }" "$PROJECT_TITLE" "$SYSID_MSG" "$SYSID_MENU"
								;;
		                    *)
								# Auswahl übernehmen
								SYSID="$gv_Auswahl"
								break
		                        ;;
		                esac
		            done
					# falls die Var. SYSID leer ist mit dem Wert "LINUX/UNIX"
					# belegen.
					SYSID="${SYSID:-LINUX/UNIX}"
					## }}}
					burn_opt_menu $lv_Sysid
					;;
				$lv_Symlinks)
		            # Behandlung von Symlinks einstellen# {{{
		            SYMLINKS_MENU=(\"$lv_SL_None\" \"\" \"$lv_SL_Discard_Broken\" \"\"
				   	\"$lv_SL_Discard_All\" \"\" \"$lv_SL_Follow\" \"\")
		            SYMLINKS_MSG=$(gettext 'Wählen Sie einen Menüpunkt zur Behandlung von symbolischen Links aus.')
			        menubox "" "$PROJECT_TITLE" "$SYMLINKS_MSG" "$SYMLINKS_MENU"
					while [ "$gv_Auswahl" ] ; do
						case $gv_Auswahl in
							HELP*)
					    	    # Hilfe Messagebox
								script_help share/burn_opt_symlink_help
			        			menubox "${gv_Auswahl#HELP }" "$PROJECT_TITLE" "$SYMLINKS_MSG" "$SYMLINKS_MENU"
								;;
		                    *)
								# Auswahl übernehmen.
								SYMLINKS="$gv_Auswahl_Display"
								break
		                        ;;
		                esac
		            done
					# falls die Var. SYMLINKS leer ist mit dem Wert "none"
					# belegen.
					SYMLINKS="${SYMLINKS:-$lv_SL_None}"
					## }}}
					burn_opt_menu $lv_Symlinks
					;;
				$lv_DatatrackMode)
		            # Schreib-Modus einstellen# {{{
		            DATATRACK_MODE_MENU=(auto \"\" MODE1 \"\" MODE2 \"\")
		            DATATRACK_MODE_MSG=$(gettext 'Wählen Sie einen Datentrack Modus aus.')
			        menubox "$DATAMODE" "$PROJECT_TITLE" "$DATATRACK_MODE_MSG" "$DATATRACK_MODE_MENU"
					while [ "$gv_Auswahl" ] ; do
						case $gv_Auswahl in
							HELP*)
					    	    # Hilfe Messagebox
								script_help share/burn_opt_datatrackmode_help
			        			menubox "${gv_Auswahl#HELP }" "$PROJECT_TITLE" "$DATATRACK_MODE_MSG" "$DATATRACK_MODE_MENU"
								;;
		                    *)
								# Auswahl übernehmen
								DATAMODE="$gv_Auswahl"
								break
		                        ;;
		                esac
		            done
					# falls die Var. DATAMODE leer ist mit dem Wert "MODE1"
					# belegen.
					DATAMODE="${DATAMODE:-auto}"
					## }}}
					burn_opt_menu $lv_DatatrackMode
					;;
				$lv_Multisession)
		            # Multisession einstellen# {{{
					# Wenn das Medium schon eine Multisession besitzt eine andere Auswahl anbieten.
					if [[ $IS_MULTISESSION == yes ]] ; then
			            MULTISESSION_MENU=($lv_Auto  \"\" \"$lv_Continue_Multisession\" \"\"
						\"$lv_Finish_Multisession\" \"\")
					else
			            MULTISESSION_MENU=($lv_Auto  \"\" \"$lv_No_Multisession\"  \"\"
					   	\"$lv_Start_Multisession\"  \"\" \"$lv_Continue_Multisession\" \"\"
						\"$lv_Finish_Multisession\" \"\")
					fi
		            MULTISESSION_MSG=$(gettext 'Wählen Sie einen Multisession Typ aus.')
			        menubox "" "$PROJECT_TITLE" "$MULTISESSION_MSG" "$MULTISESSION_MENU"
					while [ "$gv_Auswahl" ] ; do
						case $gv_Auswahl in
							HELP*)
					    	    # Hilfe Messagebox
								script_help share/burn_opt_multisession_help
			        			menubox "${gv_Auswahl#HELP }" "$PROJECT_TITLE" "$MULTISESSION_MSG" "$MULTISESSION_MENU"
								;;
		                    $lv_Auto)
								# Auswahl übernehmen
								MULTISESSION="auto"
								break
		                        ;;
		                    $lv_No_Multisession)
								# Auswahl übernehmen
								MULTISESSION="no"
								break
		                        ;;
		                    $lv_Start_Multisession)
								# Auswahl übernehmen
								MULTISESSION="start"
								break
		                        ;;
		                    $lv_Continue_Multisession)
								# Auswahl übernehmen
								MULTISESSION="continue"

								break
		                        ;;
		                    $lv_Finish_Multisession)
								# Auswahl übernehmen
								MULTISESSION="finish"
								break
		                        ;;
		                esac
		            done
					# falls die Var. MULTISESSION leer ist mit dem Wert "auto"
					# belegen und wenn nötig CD einlesen.
					MULTISESSION="${MULTISESSION:-auto}"
					## }}}
					burn_opt_menu $lv_Multisession
					;;
				$lv_Burn)
					# Optionen sammeln# {{{
					# Laufwerke prüfen# {{{
					case "$PROJECT_TITLE" in
						$gv_Cdcopy|$gv_Dvdcopy)
							if [ -n "$READ_DEVICE" ] ; then
								# Laufwerk in eine blockorientiertes Device konvertieren.
								device_convert -i $READ_DEVICE
								# A = Leserechte der Gruppe prüfen
								if ! user_device_check $CDROM A ; then
									return 1
								else
									R_CD="$CDROM"
									R_DVD="$CDROM"
								fi
							else
								no_source_device_msg
								return 1
							fi
							if [ -n "$WRITE_DEVICE" ] ; then
								# Laufwerk in eine blockorientiertes Device konvertieren.
								device_convert -i $WRITE_DEVICE
								# AI = Lese- und Schreibrechte der Gruppe prüfen
								if ! user_device_check $CDROM AI ; then
									return 1
								else
									W_CD="$CDROM"
									W_DVD="$CDROM"
								fi
							else
								no_burn_device_msg
								return 1
							fi
							;;
						*)
							if [ -n "$WRITE_DEVICE" ] ; then
								# Laufwerk in eine blockorientiertes Device konvertieren.
								device_convert -i $WRITE_DEVICE
								# AI = Lese- und Schreibrechte der Gruppe prüfen
								if ! user_device_check $CDROM AI ; then
									return 1
								else
									W_CD="$CDROM"
									W_DVD="$CDROM"
								fi
							else
								no_burn_device_msg
								return 1
							fi
							;;
					esac
					## }}}
					#
					unset -- MKISOFS_OPT
					case "$PROJECT_TITLE" in
						$gv_Audio_Cd)	# keine Optionen
							if [ "$SIMULATE" = yes -o "$CREATE_IMAGE_ONLY" = yes ] ; then
								COPYNR=1
							fi
							;;
						*)
							# Dateisystem# {{{
							case "$SYSID" in
								LINUX/UNIX)
									MKISOFS_OPT="-U -R -gui -graft-points -max-iso9660-filenames -cache-inodes -iso-level 4"
									if [[ $SYMLINKS == $lv_SL_Follow ]] ; then
										MKISOFS_OPT="$MKISOFS_OPT -f"
									fi
									;;
								LINUX/UNIX+WINDOWS)
									MKISOFS_OPT="-U -R -J -joliet-long -gui -graft-points -max-iso9660-filenames -cache-inodes -iso-level 4"
									if [[ $SYMLINKS == $lv_SL_Follow ]] ; then
										MKISOFS_OPT="$MKISOFS_OPT -f"
									fi
									;;
								DOS)
									# -ldots führender Punkt im Dateinamen mit Unterstrich tauschen
									# -input-charset cp437 für DOS
									# -f folge symbolischen Links falls kein Rock Ridge eingeschaltet ist
									MKISOFS_OPT="-ldots -input-charset cp437 -no-cache-inodes -iso-level 2"
									if [[ $SYMLINKS == $lv_SL_Follow ]] ; then
										MKISOFS_OPT="$MKISOFS_OPT -f"
									fi
									;;
								UDF)
									MKISOFS_OPT="-U -R -J -joliet-long -gui -graft-points -udf -max-iso9660-filenames -cache-inodes -iso-level 4"
									if [[ $SYMLINKS == $lv_SL_Follow ]] ; then
										MKISOFS_OPT="$MKISOFS_OPT -f"
									fi
									;;
							esac
							## }}}
							# Prüfung der Variablen IMAGE# {{{
							if [[ -n $IMAGE ]] ; then
								for i in ${=IMAGE} ; {
									case "$i" in
										create)
											CREATE_IMAGE=yes
											;;
										only)
											CREATE_IMAGE_ONLY=yes
											;;
										delete)
											DEL_IMAGE=yes
											;;
									esac
								}
							else
								CREATE_IMAGE=no
								CREATE_IMAGE_ONLY=no
								DEL_IMAGE=no
							fi
							## }}}
							# -A application_id
							# -p preparer
							# -V volid
							# -C last_sess_start,next_sess_start für Multisession CDs.
							if [ -n "$VOLID" ] ; then
								MKISOFS_OPT="$MKISOFS_OPT -V \"$VOLID\" -volset=\"$VOLID\""
							else
								# VOLID=none wird für das kopieren von Medien gebraucht.
								VOLID=none
								MKISOFS_OPT="$MKISOFS_OPT -V none -volset=none"
							fi
							# Programm
							if [ -n "$APPID" ] ; then
								MKISOFS_OPT="$MKISOFS_OPT -A \"$APPID\""
							else
								MKISOFS_OPT="$MKISOFS_OPT -A ${gv_ScriptName}"
							fi
							if [ -n "$PUBLISHER" ] ; then
								MKISOFS_OPT="$MKISOFS_OPT -publisher=\"$PUBLISHER\""
							fi
							if [ -n "$PREPARER" ] ; then
								MKISOFS_OPT="$MKISOFS_OPT -p \"$PREPARER\""
							fi
							case "$SYMLINKS" in
								follow)
									MKISOFS_OPT="$MKISOFS_OPT -f"
									;;
							esac
							# und der Rest
							# -volset-size Anzahl der CDs in einem Volumeset (volset)
							# -volset-seqno Nummer der CD in einem Volumeset
							MKISOFS_OPT="$MKISOFS_OPT -sysid=\"$SYSID\" -volset-size 1 -volset-seqno 1"
							;;
					esac
					## }}}
					return 0
					;;
				$gv_Back)
					return 1
					;;
			esac
		done
		return 0
	}
	## }}}
	# Funktion (burn_var) variable Variablen# {{{
	#
	burn_var() {
		CDRDAO_TOC="${TMP_DIR:-/var/tmp}/cdrdao.toc"
		CREATE_ISO_MSG=$(gettext 'erstelle iso9660 Dateisystem (${TMP_DIR%/}/${VOLID// /_}.iso).')
		BURN_CD_PROGRESS_MSG=$(gettext 'brenne CD.')
		BURN_CD_PROGRESS1_MSG=$(gettext 'brenne kopierte CD: ${TMP_DIR}/${VOLID// /_}.img.')
		COPY_CD_PROGRESS_MSG=$(gettext 'kopiere CD.')
		COPY_CD_PROGRESS1_MSG=$(gettext 'kopiere CD: --> ${TMP_DIR}/${VOLID// /_}.img.')
		BURN_DVD_PROGRESS_MSG=$(gettext 'brenne DVD.')
		BURN_DVD_PROGRESS1_MSG=$(gettext 'brenne kopierte DVD: ${TMP_DIR}/${VOLID// /_}.img.')
		COPY_DVD_PROGRESS_MSG=$(gettext 'kopiere DVD.')
		COPY_DVD_PROGRESS1_MSG=$(gettext 'kopiere DVD: --> ${TMP_DIR}/${VOLID// /_}.img.')
		FILE_CHOICE_MSG=$(gettext 'Wählen Sie eine oder mehrere Dateien aus.')
	}
	## }}}
	# Funktion (cd_dvd_burn), um CD/DVD's zu brennen# {{{
	#
	# usage:
	# cd_dvd_burn [ --copycd | --datacd | --isocd | --mp3cd | --oggcd | --photocd | --wavcd ]
	# cd_dvd_burn [ --vcd | --vdvd ]
	# cd_dvd_burn [ --copydvd | --datadvd | --isodvd | --mp3dvd | --oggdvd | --photodvd | --wavdvd ]
	#
	cd_dvd_burn() {
		# Konfiguration einlesen
		read_file cd_dvdrc
		
		unset -- gv_Format VERZ CDROM
		local Anz
		integer Anz
		
	    if [ ! -d "$TMP_DIR" ] ; then
	        TMP_DIR="/var/tmp"
	    fi
		# Auf benötigte Programme prüfen
		prog_check cdrdao dvd+rw-mediainfo genisoimage growisofs wodim
		if [ -n "$NO_PROGS" ] ; then
			return 1
		fi
		
		case $1 in
			--copy*)
				# CD/DVD kopieren# {{{
				if [ "$1" = --copycd -a "$CD_PROG" = cdrdao ] ; then
					# Dialog Title erstellen
					PROJECT_TITLE="$gv_Cdcopy"
					# CD kopieren (cdrdao)
					PROG="$CD_PROG"
					copy_cd_dvd cd
				elif [ "$1" = --copydvd -a "$DVD_PROG" = growisofs ] ; then
					# Dialog Title erstellen
					PROJECT_TITLE="$gv_Dvdcopy"
					# DVD kopieren (growisofs)
					PROG="$DVD_PROG"
					copy_cd_dvd dvd
				else
					wrong_parameter_msg "$0"
					return 1
				fi
				return 0
				## }}}
				;;
			--data*)
				# Daten brennen{{{
				if [ "$1" = --datacd -a "$CD_PROG" = cdrdao ] ; then
					# Dialog Title erstellen
					PROJECT_TITLE="$gv_Data_Cd"
					# CD brennen
					PROG="$CD_PROG"
					image_burn
				elif [ "$1" = --datadvd -a "$DVD_PROG" = growisofs ] ; then
					# Dialog Title erstellen
					PROJECT_TITLE="$gv_Data_Dvd"
				    #gv_Format=data
					PROG="$DVD_PROG"
					image_burn
				else
					wrong_parameter_msg "$0"
					return 1
				fi
				return 0
				#}}}
				;;
			--iso*)
				# Iso Images brennen{{{
				#
				FORMAT="ISO"
				gv_Format=iso
				SUFFIX=".iso .Iso .ISO"
				#
				if [ "$1" = --isocd -a "$CD_PROG" = cdrdao ] ; then
					# Dialog Title erstellen
					PROJECT_TITLE="$gv_Iso_Cd"
					# CD brennen
					PROG="$CD_PROG"
					image_burn
				elif [ "$1" = --isodvd -a "$DVD_PROG" = growisofs ] ; then
					# Dialog Title erstellen
					PROJECT_TITLE="$gv_Iso_Dvd"
					# DVD brennen
					PROG="$DVD_PROG"
					image_burn
				else
					wrong_parameter_msg "$0"
					return 1
				fi
				return 0
				#}}}
				;;
			--mp3*)
				# Hier werden MP3 Dateien gebrannt{{{
				#
				FORMAT="MP3"
				gv_Format="mp3"
				SUFFIX=".mp3 .Mp3 .MP3"
				#
				if [ "$1" = --mp3cd -a "$CD_PROG" = cdrdao ] ; then
					# Dialog Title erstellen
					PROJECT_TITLE="$gv_Data_Cd"
					# CD brennen
					PROG="$CD_PROG"
					image_burn
				elif [ "$1" = --mp3dvd -a "$DVD_PROG" = growisofs ] ; then
					# Dialog Title erstellen
					PROJECT_TITLE="$gv_Data_Dvd"
					PROG="$DVD_PROG"
					image_burn
				else
					wrong_parameter_msg "$0"
					return 1
				fi
				return 0
				#}}}
				;;
			--ogg*)
				# Hier werden OGG Dateien gebrannt{{{
				#
				FORMAT="OGG"
				gv_Format="ogg"
				SUFFIX=".ogg .Ogg .OGG"
				#
				if [ "$1" = --oggcd -a "$CD_PROG" = cdrdao ] ; then
					# Dialog Title erstellen
					PROJECT_TITLE="$gv_Data_Cd"
					# CD brennen
					PROG="$CD_PROG"
					image_burn
				elif [ "$1" = --oggdvd -a "$DVD_PROG" = growisofs ] ; then
					# Dialog Title erstellen
					PROJECT_TITLE="$gv_Data_Dvd"
					# DVD brennen
					PROG="$DVD_PROG"
					image_burn
				else
					wrong_parameter_msg "$0"
					return 1
				fi
				return 0
				#}}}
				;;
			--photo*)
				# Bilder brennen{{{
				#
				FORMAT="IMAGE"
				gv_Format="photo"
				#
				if [ "$1" = --photocd -a "$CD_PROG" = cdrdao ] ; then
					# Dialog Title erstellen
					PROJECT_TITLE="$gv_Photo_Cd"
					# CD brennen
					PROG="$CD_PROG"
					image_burn
				elif [ "$1" = --photodvd -a "$DVD_PROG" = growisofs ] ; then
					# Dialog Title erstellen
					PROJECT_TITLE="$gv_Photo_Dvd"
					# DVD brennen
					PROG="$DVD_PROG"
					image_burn
				else
					wrong_parameter_msg "$0"
					return 1
				fi
				return 0
				#}}}
				;;
			--vcd)
				# Video CDs brennen{{{
				#
				FORMAT="VCD"
				gv_Format="Video-CD"
				SUFFIX=".cue .Cue .CUE .ccd .Ccd .CCD"
				#
				if [ "$CD_PROG" = cdrdao ] ; then
					# Dialog Title erstellen
					PROJECT_TITLE="$gv_Video_Cd"
					# CD brennen
					PROG="$CD_PROG"
					image_burn
				else
					wrong_parameter_msg "$0"
					return 1
				fi
				return 0
				#}}}
				;;
			--vdvd)
				# Video DVDs brennen{{{
				#
				gv_Format="Video-DVD"
				#
				if [ "$DVD_PROG" = growisofs ] ; then
					# Dialog Title erstellen
					PROJECT_TITLE="$gv_Video_Dvd"
					# DVD brennen
					PROG="$DVD_PROG"
					image_burn
				else
					wrong_parameter_msg "$0"
					return 1
				fi
				#}}}
				;;
			--wav*)
				# WAV Dateien brennen{{{
				#
				FORMAT="WAVE"
				gv_Format="wav"
				SUFFIX=".wav .Wav .WAV"
				#
				if [ "$1" = --wavcd -a "$CD_PROG" = cdrdao ] ; then
					# Dialog Title erstellen
					PROJECT_TITLE="$gv_Audio_Cd"
					# CD brennen
					PROG="$CD_PROG"
					image_burn 
				elif [ "$1" = --wavdvd -a "$DVD_PROG" = growisofs ] ; then
					# Dialog Title erstellen
					PROJECT_TITLE="$gv_Audio_Dvd"
					# DVD brennen
					PROG="$DVD_PROG"
					image_burn
				else
					wrong_parameter_msg "$0"
					return 1
				fi
				return 0
				#}}}
				;;
		esac
		rm -rf $gv_LogFile$$ ${gv_WorkDir}/filelist &>/dev/null
		return 0
	}
	## }}}
	# Funktion (cd_dvd_conf), Brenneinstellung{{{
	#
	# usage: cd_dvd_conf -a | -R | -W
	# -a - alles konfigurieren.
	# -R - nur Leselaufwerk konigurieren.
	# -W - nur was zum brennen benötigt wird konfigurieren.
	#
	cd_dvd_conf() {
		if [[ ${#argv} == 1 ]] ; then
			local Opt
			#
			# Falls es keine ~/.kwtools/cd_dvdrc gibt oder die Umgebungs Variabeln 
			# leer sind, müssen noch einige Brennparameter eingestellt werden.
			#
			OPT="$1"
			case "$OPT" in
				-a)	#
					# alles konfigurieren{{{
					#
					# Lesedevice
					if [ -z "$READ_DEVICE" ] ; then
						cd_dvd_device
						check_read_device $DEVICE
					fi
					# Brenndevice
					if [ -z "$WRITE_DEVICE" ] ; then
						cd_dvd_device
						check_write_device $DEVICE
					fi
					# Leselaufwerkstreiber
					if [ -z "$CD_SOURCE_DRIVER" ] ; then
						device_driver
						check_source_driver $DRIVER
					fi		
					# Brenner Laufwerkstreiber
					if [ -z "$CD_WRITE_DRIVER" ] ; then
						device_driver
						check_write_driver $DRIVER
					fi		
					#}}}
					;;
				-R)
					# Bei (Video)CD rippen wird nur das Lese Laufwerk benötigt{{{
					#
					if [ -z "$READ_DEVICE" ] ; then
						cd_dvd_device
						check_read_device $DEVICE
					fi
					#}}}
					;;
				-W)
					# Beim schreiben wird nur das Brenn Laufwerk, Speed,{{{
					# Treiber und die CD/DVD Grösse benötigt.
					#
					# Schreib-Gerät
					if [ -z "$WRITE_DEVICE" ] ; then
						cd_dvd_device
						check_write_device $DEVICE
					fi
					# CD-Treiber
					if [ -z "$CD_WRITE_DRIVER" ] ; then
						device_driver
						check_write_driver $DRIVER
					fi		
					#}}}
					;;
				*)	# falsche Parametereingabe
					wrong_parameter_msg "$0"
					return 1
					;;
			esac
		else
			no_para_msg $0
			return 1
		fi
		return 0
	}
	#}}}
	# Funktion (cd_dvd_config), um die Konfiguration zu schreiben{{{
	#
	# usage: cd_dvd_config
	#
	cd_dvd_config() {
	#
	# ~/.kwtools/cd_dvdrc schreiben
	#
	> ${gv_HomePath}/.kwtools/cd_dvdrc <<< "# Beginn ~/.kwtools/cd_dvdrc
#
# Autor: Kai Wilke <kiste@netzworkk.de>

# Dies sind ein paar Brennereinstellungen für alle Programme
# die die Funktion cd_dvd_burn benutzen. Dies sind unter anderem
# kwrecord, kwsnd2sndfm, kwvcdburn und kwvdvdburn.

# Es konfiguriert CD wie DVD Brenner.

# CD Brennprogramm angeben.
CD_PROG=\"$CD_PROG\"

# DVD Brennprogramm angeben.
DVD_PROG=\"$DVD_PROG\"

# Brenner Device (z.B. bus,id,lun - 0,1,0 oder /dev/sr0)
WRITE_DEVICE=\"$WRITE_DEVICE\"

# Leselaufwerk (z.B. bus,id,lun - 0,1,0 oder /dev/sr0)
READ_DEVICE=\"$READ_DEVICE\"

# Treiber für den Brenner einstellen
CD_WRITE_DRIVER=\"$CD_WRITE_DRIVER\"

# Treiber für das Leselaufwerk einstellen (in einigen Fällen wichtig, wie Copy_CD)
CD_SOURCE_DRIVER=\"$CD_SOURCE_DRIVER\"

# CDDB - CD-Datenbank Server eingeben, getrennt durch ein Komma oder Leerzeichen.
# Syntax siehe Hilfe oder man 1 cdrdao.
CDDB=\"$CDDB\"

# Temporäres Standard Verzeichnis zur Erstellung der Image-Dateien.
TMP_DIR=\"$TMP_DIR\"

# Soll die CD/DVD nach dem brennen ausgeworfen werden (yes/no)?
EJECT=\"$EJECT\"

# End ~/.kwtools/cd_dvdrc"
	#
	read_file cd_dvdrc
	}
	#}}}
	# Funktion (cd_dvd_device), Laufwerke Auswahl {{{
	#
	# benötigt die Funktion no_dev_cd
	#
	# usage: cd_dvd_device
	#
	cd_dvd_device() {
		#
		# Gibt es CD/DVD Laufwerke werden sie zur Auswahl gestellt.
		# Die Variable/Array STL_CD_DEV wird von der Funktion cdrom erstellt.
		#
		if [ -n "${STL_CD_DEV_E[1]}" ] ; then
			DEV_TITLE=$(gettext 'Konfiguration::Laufwerke')
			DEV_MSG=$(gettext 'Wählen Sie ein Laufwerk aus.')
			DEV_MENU=($STL_CD_DEV_E)
			menubox "$DEVICE" "$DEV_TITLE" "$DEV_MSG" "$DEV_MENU"
			while [ "$gv_Auswahl" ] ; do
				case $gv_Auswahl in
					HELP*) script_help share/cdrom_help
						menubox "${gv_Auswahl#HELP }" "$DEV_TITLE" "$DEV_MSG" "$DEV_MENU"
						;;
					*)	# Auswahl uebrnehmen
						DEVICE="$gv_Auswahl"
						break
						;;
				esac
			done
		else
			no_dev_cd
		fi
	}
	#}}}
	# Funktion (check_cddb), für eine CD-Datenbank# {{{
	#
	check_cddb() {
		if [ -n "$CDDB" ] ; then
			CDRDAO_CDDB_OPT="--with-cddb --cddb-servers $CDDB"
		else
			unset -- CDRDAO_CDDB_OPT
		fi
	}
	## }}}
	# Funktion (check_cd_state), CD Status prüfen# {{{
	#
	# Zur Zeit wird nur cdrdao unterstützt
	#
	# usage: check_cd_state DEVICE
	#
	check_cd_state() {
		if [[ ${#argv} = 1 ]] ; then
			unset -- CD_RW CD_R_EMPTY CD_APPENDABLE ID_LABEL CD_IS_CAP CD_ALL_CAP CD_TOC
			local Dev Cap_Is_Tmp Cap_All_Tmp
			Dev="$1"
			integer -x CD_IS_CAP CD_ALL_CAP
			eject -t "$Dev" &>/dev/null
			# 2 Sekunden warten
			sleep 2
			#
			### cdrdao ###
			cdrdao disk-info --device $Dev 2>/dev/null >${gv_WorkDir}/cd_state
			CD_RW=${${(ws,: ,)${(M)${(f)"$(< ${gv_WorkDir}/cd_state)"}##CD-RW*}}[2]}
			CD_R_EMPTY=${${(ws,: ,)${(M)${(f)"$(< ${gv_WorkDir}/cd_state)"}##*empty*}}[2]}
			CD_TOC=${${(ws,: ,)${(M)${(f)"$(< ${gv_WorkDir}/cd_state)"}##*Toc Type*}}[2,$]}
			CD_APPENDABLE=${${(ws,: ,)${(M)${(f)"$(< ${gv_WorkDir}/cd_state)"}##Appendable*}}[2]}
			### wodim ###
			Cap_All_Tmp=${${${(ws,: ,)$(wodim -atip -dev $Dev | grep 'ATIP.*out:')}[2]}% *}
			(( CD_ALL_CAP = Cap_All_Tmp * 2048 ))
			### sysfs ###
			Cap_Is_Tmp=$(< /sys/block/${Dev##*/}/size)
			(( CD_IS_CAP = Cap_Is_Tmp * 512 ))
			### udisk2 ###
			udisksctl info -b $Dev 2>/dev/null >${gv_WorkDir}/udisk2_state
			ID_LABEL=${${(ws, ,)${(M)${(f)"$(< ${gv_WorkDir}/udisk2_state)"}##*IdLabel*}}[2,$]}
			if [[ -z $VOLID ]] && [[ -n $ID_LABEL ]] ; then
				VOLID="$ID_LABEL"
			fi
		else
			no_para_msg $0
			return 1
		fi
		return 0
	}
	## }}}
	# Funktion (check_cd_toc_type), prüft ob Audio oder Daten CD ist# {{{
	# und dementsprechen die Variable CDRDAO_OPT für das cdrdao Komando
	# read-cd belegen.
	#
	# usage: check_cd_toc_type
	#
	check_cd_toc_type() {
		unset -- CDRDAO_OPT
		case "$CD_TOC" in
			'CD-DA or CD-ROM')
				# Audio CD, mit und ohne cddb Server
				if [ -n "$CDDB" ] ; then
					CDRDAO_OPT="--with-cddb --cddb-servers $CDDB"
				fi
				;;
			'CD-ROM XA')
				# Mixed oder Daten CD
				CDRDAO_OPT="--read-raw"
				;;
		esac
	}
	## }}}
	# Funktion (check_dvd_state), DVD Status prüfen# {{{
	#
	# Zur Zeit werden nur die dvd+rw-tools unterstützt
	#
	# usage: check_dvd_state DEVICE
	# DEVICE - DVD/BD
	#
	check_dvd_state() {
		if [[ ${#argv} == 1 ]] ; then
			local Dev Tmp
			Dev="$1"
			unset -- SESSION_SECTOR DVD_MEDIUM DVD_STATUS DVD_IS_CAP Tmp \
				BLOCK_SIZE DVD_SPEED ID_LABEL TRACK_NR
			integer -x DVD_SPEED DVD_IS_CAP BLOCK_SIZE TRACK_NR
			eject -t "$Dev" &>/dev/null
			# 2 Sekunden warten
			sleep 2
			#
			dvd+rw-mediainfo $Dev >${gv_WorkDir}/dvd_state
			DVD_MEDIUM=${${${(ws:, :)${(M)${(f)"$(< ${gv_WorkDir}/dvd_state)"}##*(Mounted Media)*}}[2]}% *}
	        DVD_STATUS=${${${(ws,:,)${(M)${(f)"$(< ${gv_WorkDir}/dvd_state)"}##*(Disc status)*}}[2]}##* }
			BLOCK_SIZE=${${${(s,=,)${(M)${(f)"$(< ${gv_WorkDir}/dvd_state)"}##*(READ CAPACITY)*}}[1]}##*\*}
	        TRACK_NR=${${${(ws,:,)${(M)${(f)"$(< ${gv_WorkDir}/dvd_state)"}##*Number of Tracks*}}[2]}##* }
			(( TRACK_NR ++ ))
			Tmp=${${${(s,:,)${(M)${(f)"$(< ${gv_WorkDir}/dvd_state)"}##*(Track Size)*}}[TRACK_NR]}%%\**}
			(( DVD_IS_CAP = Tmp * BLOCK_SIZE ))
	        DVD_SPEED=${${${(ws,x,)${(M)${(f)"$(< ${gv_WorkDir}/dvd_state)"}##*Write Speed *}}[1]}##* }
			### udisk2 ###
			udisksctl info -b $Dev 2>/dev/null >${gv_WorkDir}/udisk2_state
			ID_LABEL=${${(ws, ,)${(M)${(f)"$(< ${gv_WorkDir}/udisk2_state)"}##*IdLabel*}}[2,$]}
			if [[ -z $VOLID ]] && [[ -n $ID_LABEL ]] ; then
				VOLID="$ID_LABEL"
			fi
		else
			no_para_msg $0
			return 1
		fi
		return 0
	}
	## }}}
	# Funktion (check_eject), CD/DVD auswerfen?{{{
	#
	# usage: check_eject PROG DEVICE
	# PROG - cdrdao/growisofs
	# DEVICE - Laufwerk welches ausgeworfen werden soll.
	#
	check_eject() {
		if [[ ${#argv} == 2 ]] ; then
			local Prog Dev
			Prog="$1"
			Dev="$2"
			case $Prog in
				cdrdao)
					if [ "$EJECT" = yes ] ; then
						Eject="--eject"
					else
						unset -- Eject
					fi
					;;
				growisofs)
					if [ "$EJECT" = yes ] ; then
						eject "$Dev" &>/dev/null
					fi
					;;
			esac
		else
			no_para_msg $0
			return 1
		fi
		return 0
	}
	#}}}
	# Funktion (check_exec_dd), nach dd(_rescue) suchen und ausführen - nur DVD# {{{
	# Mit dd(_rescue) eine temporäre Datei erstellen (1:1 Kopie).
	#
	# usage: check_exec_dd DEVICE SIZE
	# DEVICE - Laufwerk von welchem kopiert werden soll
	# SIZE - Grösse in Blocks die kopiert werden soll in 1 Block = 2048 Bytes.
	#
	check_exec_dd() {
	if [[ ${#argv} == 2 ]] ; then
		local Dev Dev_Size
		Dev="$1"
		Dev_Size="$2"
		if [[ -x ${commands[dd_rescue]} ]] ; then
			dd_rescue -b 2048 -m $Dev_Size $Dev ${TMP_DIR%/}/${VOLID// /_}.img 2>&1 | progressbox "$BURN_PROGRESS_TITLE" "$COPY_DVD_PROGRESS1_MSG" || (print ; prog_failure)
		else
			dd if=${Dev} of=${TMP_DIR%/}/${VOLID// /_}.iso bs=2k count=$Dev_Size >/dev/null 2>$gv_LogFile &
			dd_gauge "dd if=${Dev} of=${TMP_DIR%/}/${VOLID// /_}.img bs=2k count=${Dev_Size}" "$Dev_Size" "$COPY_DVD_PROGRESS1_MSG"
		fi
	else
		no_para_msg $0
		return 1
	fi
	return 0
	}
	## }}}
	# Funktion (check_multisession); prüft die Variable MULTISESSION# {{{
	#
	# usage check_multisession PROG MULTISESSION
	# PROG - Brennprogramm
	# MULTISESSION - Variable die den Wert enthält wie/ob
	# Multisessions gebrannt werden sollen
	#
	check_multisession() {
		if [[ ${#argv} == 2 ]] ; then
			unset -- MS_START MS_FINISH CDRDAO_MS_OPT WODIM_MS_OPT CD_ROM_TYPE DATAMODE
			local Prog Multisession
			Prog="$1"
			Multisession="$2"
			if [[ $Prog == growisofs ]] ; then
				case $Multisession in
					auto)
						# Bei auto und das Medium ist schon eine Multisession DVD
						# wird diese beim brennen nicht abgeschlossen.
						if [[ $IS_MULTISESSION == yes ]] ; then
							MS_START=no
							MS_FINISH=no
						else
							MS_START=yes
							MS_FINISH=yes
						fi
						;;
					no)
						MS_START=yes
						MS_FINISH=yes
						;;
					start)
						MS_START=yes
						MS_FINISH=no
						;;
					continue)
						MS_START=no
						MS_FINISH=no
						;;
					finish)
						MS_START=no
						MS_FINISH=yes
						;;
				esac
			elif [[ $Prog == cdrdao ]] ; then
				# Für Multisession mus CD_ROM_TYPE=CD_ROM_XA angegeben werden.
				case $Multisession in
					auto)
						# Bei auto und das Medium ist schon eine Multisession CD
						# wird diese beim brennen nicht abgeschlossen.
						if [[ $IS_MULTISESSION == yes ]] ; then
							CD_ROM_TYPE=CD_ROM_XA
							DATAMODE=MODE2_FORM1
							CDRDAO_MS_OPT="--multi"
							WODIM_MS_OPT="-multi"
							if [ -n "$SESSION_SECTOR" ] ; then
								MKISOFS_OPT="$MKISOFS_OPT -C $SESSION_SECTOR"
							fi
						else
							unset -- CDRDAO_MS_OPT WODIM_MS_OPT
							case $gv_Format in
								wav)
									CD_ROM_TYPE=CD_DA
									DATAMODE=AUDIO
									;;
								*)
									CD_ROM_TYPE=CD_ROM
									DATAMODE=${DATAMODE:-MODE1}
									;;
							esac
						fi
						;;
					start)
						if [[ $IS_MULTISESSION != yes ]] ; then
							CD_ROM_TYPE=CD_ROM_XA
							DATAMODE=MODE2_FORM1
							CDRDAO_MS_OPT="--multi"
							WODIM_MS_OPT="-multi"
						else
							MSG=$(gettext 'Diese CD besitzt schon eine Session. Sie müssen diese CD erst löschen oder einen leeren Rohling einlegen. Es wird abgebrochen.')
							msgbox "$gv_Info" "$MSG"
							return 1
						fi
						;;
					continue)
						if [[ $IS_MULTISESSION == yes ]] ; then
							CD_ROM_TYPE=CD_ROM_XA
							DATAMODE=MODE2_FORM1
							CDRDAO_MS_OPT="--multi"
							WODIM_MS_OPT="-multi"
							if [ -n "$SESSION_SECTOR" ] ; then
								MKISOFS_OPT="$MKISOFS_OPT -C $SESSION_SECTOR"
							fi
						else
							unset -- CDRDAO_MS_OPT WODIM_MS_OPT
							case $gv_Format in
								wav)
									CD_ROM_TYPE=CD_DA
									DATAMODE=AUDIO
									;;
								*)
									CD_ROM_TYPE=CD_ROM
									DATAMODE=${DATAMODE:-MODE1}
									;;
							esac
						fi
						;;
					finish)
						if [[ $IS_MULTISESSION == yes ]] ; then
							CD_ROM_TYPE=CD_ROM_XA
							DATAMODE=MODE2_FORM1
							if [ -n "$SESSION_SECTOR" ] ; then
								MKISOFS_OPT="$MKISOFS_OPT -C $SESSION_SECTOR"
							fi
							unset -- CDRDAO_MS_OPT
						else
							unset -- CDRDAO_MS_OPT WODIM_MS_OPT
							case $gv_Format in
								wav)
									CD_ROM_TYPE=CD_DA
									DATAMODE=AUDIO
									;;
								*)
									CD_ROM_TYPE=CD_ROM
									DATAMODE=${DATAMODE:-MODE1}
									;;
							esac
						fi
						;;
					*|no)
						unset -- CDRDAO_MS_OPT WODIM_MS_OPT
						case $gv_Format in
							wav)
								CD_ROM_TYPE=CD_DA
								DATAMODE=AUDIO
								;;
							*)
								CD_ROM_TYPE=CD_ROM
								DATAMODE=${DATAMODE:-MODE1}
								;;
						esac
						;;
				esac
			fi
		else
			no_para_msg $0
			return 1
		fi
		return 0
	}
	## }}}
	# Funktion (check_read_device){{{
	#
	# usage: check_read_device DEVICE
	# DEVICE - CD/DVD Laufwerk
	#
	check_read_device() {
		if [[ ${#argv} == 1 ]] ; then
			READ_DEVICE="$1"
		else
			no_para_msg $0
			return 1
		fi
		return 0
	}
	#}}}
	# Funktion (check_simulate), auf Simulieren prüfen{{{
	#
	# usage: check_simulate PROG
	# PROG - cdrdao/growisofs/wodim
	#
	check_simulate() {
		if [[ ${#argv} == 1 ]] ; then
			local Prog
			Prog="$1"
			case $Prog in
				cdrdao|wodim)
					if [ "$SIMULATE" = yes ] ; then
						WRITE="simulate"
						COPY="copy --simulate"
						READ_CD="read-cd --simulate"
						# für wodim
						DUMMY="-dummy"
					else
						WRITE=write
						COPY=copy
						READ_CD=read-cd
						unset -- DUMMY
					fi
					;;
				growisofs)
					if [ "$SIMULATE" = yes ] ; then
						WRITE="-dry-run"
					else
						unset -- WRITE
					fi
					;;
			esac
		else
			no_para_msg $0
			return 1
		fi
		return 0
	}
	#}}}
	# Funktion (check_size_to_dir), übergebenen Platz (in Byte)# {{{
	# und benötigten Platz (in Byte) des Verzeichnisses berechnen.
	#
	# usage: check_size_to_dir SIZE DIR
	# SIZE - muss eine Grösse in Byte sein. 
	# DIR - Verzeichnis in dem die Daten gespeichert werden sollen.
	#
	check_size_to_dir() {
		if [[ ${#argv} == 2 ]] ; then
			local Size Dir
			integer Size
			Size="$1"
			Dir="$2"
			check_size "$Dir"
			# gv_Size wird von der Funktion check_size erzeugt.
			if [[ $Size -ge $gv_Size ]] ; then
				over_tmp_size_msg "$Size" "$gv_Size"
				return 1
			fi
		else
			no_para_msg $0
			return 1
		fi
		return 0
	}
	## }}}
	# Funktion (check_source_driver){{{
	#
	check_source_driver() {
		if [[ ${#argv} == 1 ]] ; then
			CD_SOURCE_DRIVER="$1"
		else
			case "$CD_PROG" in
				cdrdao)
					# Standard cdrdao CD/DVD Treiber
					CD_SOURCE_DRIVER=generic-mmc
					;;
				wodim)
					# Standard wodim CD/DVD Treiber
					CD_SOURCE_DRIVER=mmc_cd_dvd
					;;
			esac
		fi
	}
	#}}}
	# Funktion (check_symlink), prüfen wie mit einem Symlink umgegangen werden soll# {{{
	#
	# usage: check_symlink SYMLINKS
	# SYMLINK - Symlink der bearbeitet werden soll
	#
	check_symlink() {
		if [[ ${#argv} == 1 ]] ; then
			local Symlink
			Symlink="$1"
			case $SYMLINKS in
				$lv_SL_None) # keine Änderung
					print "${Symlink}=${DIR}/${Symlink}" >>${gv_WorkDir}/filelist.tmp
					;;
				$lv_SL_Discard_Broken) # nur ungültige Symlinks nicht einbeziehen
					if readlink -f "$Symlink" >/dev/null ; then
						print "${Symlink}=${DIR}/${Symlink}" >>${gv_WorkDir}/filelist.tmp
					fi
					;;
				$lv_SL_Discard_All) # keine Symlinks einbeziehen
					;;
				$lv_SL_Follow) # Symlinks folgen
					F_Sl=$(readlink -fs "$Symlink")
					if [[ -n $F_Sl ]] ; then
						print "${F_Sl}=${DIR}/${F_Sl}" >>${gv_WorkDir}/filelist.tmp
					fi
					;;
			esac
		else
			no_para_msg $0
		fi
	}
	## }}}
	# Funktion (check_write_cd), CD Rohling prüfen.# {{{
	#
	# usage: check_write_dvd DEVICE SIZE
	# DEVICES - Brenngerät
	# SIZE - Grösse der zu brennenden Daten in Bytes
	#
	check_write_cd() {
		if [[ ${#argv} == 2 ]] ; then
			unset -- SESSION_SECTOR
			local Dev Data_Size
			Dev="$1"
			Data_Size="$2"
			# CD Medium prüfen
			check_cd_state "$Dev"
			while [[ -z $CD_RW ]] ; do
				# Nachricht das kein richtiges Medium (CD) gefunden wurde
				MSG=$(gettext 'Im Laufwerk liegt kein CD Medium! Wollen Sie ein Medium einlegen (${gv_Yes}/${gv_No})?')
				yesno "$gv_Attention" "$MSG" ""
				if [[ $gv_Auswahl == yes ]] ; then
					eject "$Dev" &>/dev/null
					change_cddvd_msg
					eject -t "$Dev" &>/dev/null
					sleep 2
					check_cd_state "$Dev"
				else
					MSG=$(gettext 'Es wird abgebrochen.')
					msgbox "$gv_Info" "$MSG"
					return 1
				fi
			done
			# Prüfung
			# leeres Medium bearbeiten
			if [[ $CD_R_EMPTY == yes ]] ; then
				# Grössen prüfen Dev_Size und DVD Rohling
				if [[ $Data_Size -ge $CD_ALL_CAP ]] ; then
					# Datengrösse überschreitet die Mediumgrösse
					over_cd_size_msg "$Data_Size" "$CD_ALL_CAP"
					cp -a ${gv_WorkDir}/filelist "$IST_FILE" &>/dev/null
					unset -- $Unset
					return 1
				fi
			# Multisession CD bearbeiten
			elif [[ $CD_APPENDABLE == yes ]] ; then
				# Multisession, noch verbleibende Grösse berechnen
				(( CD_FREE_SIZE = CD_ALL_CAP - CD_IS_CAP ))
				if [[ $Data_Size -ge $CD_FREE_SIZE ]] ; then
					# Datengrösse überschreitet die Mediumgrösse
					over_cd_size_msg "$Data_Size" "$CD_FREE_SIZE"
					cp -a ${gv_WorkDir}/filelist "$IST_FILE" &>/dev/null
					unset -- $Unset
					return 1
				else
					IS_MULTISESSION=yes
					SESSION_SECTOR=$(cdrdao msinfo $Dev 2>/dev/null)
				fi
			elif [[ $CD_R_EMPTY == no ]] && [[ $CD_RW == yes ]] ; then
				# Grössen prüfen Dev_Size und DVD Rohling
				if [[ $Data_Size -ge $CD_ALL_CAP ]] ; then
					# Datengrösse überschreitet die Mediumgrösse
					over_cd_size_msg "$Data_Size" "$CD_ALL_CAP"
					cp -a ${gv_WorkDir}/filelist "$IST_FILE" &>/dev/null
					unset -- $Unset
					return 1
				fi
				# CD+-RW ersetzen?
				MSG=$(gettext 'Das Medium (CD-+RW) ist schon beschrieben. Sollen die Daten ersetzt werden (${gv_Yes}/${gv_No})?')
				yesno "$gv_Info" "$MSG" ""
				if [[ $gv_Auswahl == no ]] ; then
					cp -a ${gv_WorkDir}/filelist "$IST_FILE" &>/dev/null
					unset -- $Unset
					return 1
				else
					DEL_OPT="blank --blank-mode minimal --device $Dev --driver ${CD_WRITE_DRIVER:-generic-mmc}"
					$CD_PROG ${=DEL_OPT} 2>&1 | progressbox "$CD_DEL_TITLE" "$CD_DEL_MSG" || prog_failure
				fi
			fi
		else
			no_para_msg $0
			return 1
		fi
		return 0
	}
	## }}}
	# Funktion (check_write_device){{{
	#
	# usage: check_write_device DEVICE
	# DEVICE - CD/DVD Laufwerk
	#
	check_write_device() {
		if [[ ${#argv} == 1 ]] ; then
			WRITE_DEVICE="$1"
		else
			no_para_msg $0
			return 1
		fi
		return 0
	}
	#}}}
	# Funktion (check_write_driver){{{
	#
	check_write_driver() {
		if [[ ${#argv} == 1 ]] ; then
			CD_WRITE_DRIVER="$1"
		else
			case "$CD_PROG" in
				cdrdao)
					# Standard cdrdao CD/DVD Treiber
					CD_WRITE_DRIVER=generic-mmc
					no_input_msg
					;;
				wodim)
					# Standard wodim CD/DVD Treiber
					CD_WRITE_DRIVER=mmc_cd_dvd
					no_input_msg
					;;
			esac
		fi
	}
	#}}}
	# Funktion (check_write_dvd), DVD/BD Rohling prüfen.# {{{
	#
	# usage: check_write_dvd DEVICE SIZE
	# DEVICES - Brenngerät
	# SIZE - Grösse der zu brennenden Daten in Bytes
	#
	check_write_dvd(){
		if [[ ${#argv} == 2 ]] ; then
			local Dev Data_Size
			Dev="$1"
			Data_Size="$2"
			# DVD Medium prüfen
			check_dvd_state "$Dev"
			while [[ ${DVD_MEDIUM%[-+]*} != DVD ]] && [[ ${DVD_MEDIUM%[-+]*} != BD ]] ; do
				# Nachricht das kein richtiges Medium (DVD) gefunden wurde
				MSG=$(gettext 'Im Laufwerk liegt kein DVD/BD Medium! Wollen Sie ein Medium einlegen (${gv_Yes}/${gv_No})?')
				yesno "$gv_Attention" "$MSG" ""
				if [[ $gv_Auswahl == yes ]] ; then
					eject "$Dev" &>/dev/null
					change_cddvd_msg
					eject -t "$Dev" &>/dev/null
					sleep 2
					check_dvd_state "$Dev"
				else
					MSG=$(gettext 'Es wird abgebrochen.')
					msgbox "$gv_Info" "$MSG"
					return 1
				fi
			done
			# Prüfung
			# leeres Medium bearbeiten
			if [[ $DVD_STATUS == blank ]] ; then
					# Grössen prüfen Dev_Size und DVD/BD Rohling
				if [[ $Data_Size -ge $DVD_IS_CAP ]] ; then
					# Datengrösse überschreitet die Mediumgrösse
					over_dvd_size_msg "$Data_Size" "$DVD_IS_CAP"
					cp -a ${gv_WorkDir}/filelist "$IST_FILE" &>/dev/null
					unset -- $Unset
					return 1
				fi
			# Multisession DVD bearbeiten, nur bei DVD+-R.
			elif [[ $DVD_STATUS == appendable ]] ; then
				if [[ $Data_Size -ge $DVD_IS_CAP ]] ; then
					# Datengrösse überschreitet die Mediumgrösse
					over_dvd_size_msg "$Data_Size" "$DVD_IS_CAP"
					cp -a ${gv_WorkDir}/filelist "$IST_FILE" &>/dev/null
					unset -- $Unset
					return 1
				else
					IS_MULTISESSION=yes
				fi
			# Volles Medium bearbeiten
			elif [[ $DVD_STATUS == complete ]] ; then
				case $DVD_MEDIUM in
					DVD+RW|DVD-RW|DVD-RAM|BD-RE)
						# DVD+-RW/RAM/BD-RE ersetzen?
						MSG=$(gettext 'Das Medium ($DVD_MEDIUM) ist schon beschrieben. Sollen die Daten ersetzt werden (${gv_Yes}/${gv_No})?')
						yesno "$gv_Info" "$MSG" "no"
						if [[ $gv_Auswahl == no ]] ; then
							MS_START=no
						fi
						# Grössen prüfen Dev_Size und DVD Rohling
						if [[ $Data_Size -ge $DVD_IS_CAP ]] ; then
							# Datengrösse überschreitet die Mediumgrösse
							over_dvd_size_msg "$Data_Size" "$DVD_IS_CAP"
							cp -a ${gv_WorkDir}/filelist "$IST_FILE" &>/dev/null
							unset -- $Unset
							return 1
						fi
						;;
					DVD+R|DVD-R|BD-R)
						# Dieses Medium kann man nicht neu brennnen, Abbruch.
						MSG=$(gettext 'Dieses Medium ($DVD_MEDIUM) kann man nicht erneut brennen. Es wird abgebrochen.')
						msgbox "$gv_Info" "$MSG"
						cp -a ${gv_WorkDir}/filelist "$IST_FILE" &>/dev/null
						unset -- $Unset
						return 1
						;;
				esac
			fi
		else
			no_para_msg $0
			return 1
		fi
		return 0
	}
	## }}}
	# Funktion (copy_cd_dvd), CD/DVD kopieren{{{
	#
	# usage: copy_cd_dvd cd | dvd
	#
	copy_cd_dvd() {
		if [[ ${#argv} == 1 ]] ; then
			local Anz Opt
			integer Anz
			Opt="$1"
			# mkisofs Optionen
			if ! burn_opt ; then
				unset -- $Unset
				return 1
			fi
			burn_var
			case "$Opt" in
				cd)
					# CD kopieren# {{{
					if [ "$R_CD" -a "$W_CD" ] ; then
						# Brennlaufwerk ausbinden
						mount_check -a $W_CD
						if [[ $U_MOUNT == no ]] ; then
							return 1
						fi
						# Brennen mit nur 1 Laufwerk. # {{{
						if [ "$R_CD" = "$W_CD" ] ; then
							# cd checken ob was drauf ist
							check_cd_state "$R_CD"
							if [[ $CD_R_EMPTY == no ]] ; then
								# vorhandenen und benötigten CD Platz und
								# Laufwerksplatz berechnen.
								if ! check_size_to_dir "$CD_IS_CAP" "$TMP_DIR" ; then
									return 1
								fi
								# Laufwerk sperren
								lock "$R_CD"
								# Prüfen ob der Brennvorgang simuliert werden soll.
								check_simulate $CD_PROG
								# Prüfen ob das Medium ausgeworfen werden soll.
								check_eject $CD_PROG "$R_CD"
								# Prüfung auf welchem TOC Type, Audio oder Daten CD.
								check_cd_toc_type
								# da nur ein Laufwerk vorhanden ist
								# wird über eine tmp-Datei kopiert
								CDRDAO_TMP_OPT="--datafile ${TMP_DIR}/${VOLID// /_}.img"
								# CD rippen -> TMP_DIR
								PROG_OPT="$READ_CD -v 2 $CDRDAO_OPT $Eject --device $R_CD --driver ${CD_SOURCE_DRIVER:-generic-mmc} $CDRDAO_TMP_OPT $CDRDAO_TOC"
								# ausführen
								eval $CD_PROG ${=PROG_OPT} 2>&1 | \
									progressbox "$BURN_PROGRESS_TITLE" "$COPY_CD_PROGRESS1_MSG" || \
									(print ; lock -r "$R_CD" ; prog_failure)
								# Device unlocken
								lock -r "$R_CD"
								# Nachdem erstellen des Image ist alles
								# abgeschlossen
								if [ "$CREATE_IMAGE_ONLY" = yes ] ; then
									# fertig
									unset -- $Unset
									return 0
								fi
								# wieviel Kopien brennen
								Anz=$COPYNR
								while [ "$Anz" -ge 1 ] ; do
									W_CD="$R_CD"
									# CD wechseln
									change_cddvd_msg
									# Laufwerk einfahren
									eject -t "$W_CD" &>/dev/null
									# 2 Sekunden warten
									sleep 2
									# CD Rohling prüfen
									if ! check_write_cd "$W_CD" "$CD_IS_CAP" ; then
										return 1
									fi
									# Device locken
									lock "$W_CD"
									# Brennoptionen
									
									PROG_OPT="$WRITE -v 2 $Eject --device $W_CD --driver ${CD_WRITE_DRIVER:-generic-mmc} --overburn --force $CDRDAO_TOC"
									# ausführen
									eval $CD_PROG ${=PROG_OPT} 2>&1 | \
										progressbox "$BURN_PROGRESS_TITLE" "$BURN_CD_PROGRESS1_MSG" || \
										(print ; lock -r "$W_CD" ; prog_failure)
									# Device unlocken
									lock -r "$W_CD"
									# Ist Anz grösser als 1 wird zum wechseln
									# des Mediums aufgefordert.
									if [ "$Anz" -gt 1 ] ; then
										# CD wechseln
										change_cddvd_msg
										# Laufwerk einfahren
										eject -t "$W_CD" &>/dev/null
										# 2 Sekunden warten
										sleep 2
									fi
									(( Anz-- ))
								done
								# $CDRDAO_TOC und evtl. das Image löschen.
								rm -f $CDRDAO_TOC &>/dev/null
								if [[ -f ${TMP_DIR}/${VOLID// /_}.img ]] && \
									[[ $DEL_IMAGE == yes ]] ; then
									del_file -s "${TMP_DIR}/${VOLID// /_}.img"
								fi
								unset -- $Unset
							else
								no_data_medium_msg
								return 1
							fi
							## }}}
						else
							# Brennen mit mehreren Laufwerken.# {{{
							# cd checken ob was drauf ist.
							check_cd_state "$R_CD"
							if [[ $CD_R_EMPTY == no ]] ; then
								# Prüfen ob der Brennvorgang simuliert werden soll.
								check_simulate $CD_PROG
								# Prüfen ob das Medium ausgeworfen werden soll.
								check_eject $CD_PROG "$R_CD"
								# Bei nur Image erzeugen ist nach dieser if-Anweisung Schluss.
								if [[ $CREATE_IMAGE == yes ]] && [[ $CREATE_IMAGE_ONLY == yes ]] ; then
									# Option für das Image belegen
									CDRDAO_TMP_OPT="--datafile ${TMP_DIR}/${VOLID// /_}.img"
									# vorhandenen und benötigten CD Platz und
									# Laufwerksplatz berechnen.
									if ! check_size_to_dir "$CD_IS_CAP" "$TMP_DIR" ; then
										return 1
									fi
									# Laufwerk sperren
									lock "$R_CD"
									# Prüfung auf welchem TOC Type, Audio oder Daten CD.
									check_cd_toc_type
									# Brennoptionen
									PROG_OPT="$READ_CD -v 2 $CDRDAO_OPT $Eject --device $R_CD --driver ${CD_SOURCE_DRIVER:-generic-mmc} $CDRDAO_TMP_OPT $CDRDAO_TOC"
									
									# ausführen
									eval $CD_PROG ${=PROG_OPT} 2>&1 | \
										progressbox "$BURN_PROGRESS_TITLE" "$COPY_CD_PROGRESS1_MSG" || \
										(print ; lock -r "$R_CD" ; prog_failure)
									# Device unlocken
									lock -r "$R_CD"
									#fertig
									unset -- $Unset
									return 0
								fi
								# Laufwerk einfahren
								eject -t "$W_CD" &>/dev/null
								# 2 Sekunden warten
								sleep 2
								Anz=$COPYNR
								while [ "$Anz" -ge 1 ] ; do
									# CD Rohling prüfen
									if ! check_write_cd "$W_CD" "$CD_IS_CAP" ; then
										return 1
									fi
									# Laufwerke locken
									DEVICES="$R_CD $W_CD"
									lock "$DEVICES"
									# Brennoptionen mit oder ohne Image.
									if [[ $CREATE_IMAGE == yes ]] ; then
										# Option für das Image belegen
										CDRDAO_TMP_OPT="--datafile ${TMP_DIR}/${VOLID// /_}.img"
										PROG_OPT="$COPY -v 2 $CDRDAO_OPT $Eject --source-device $R_CD --source-driver ${CD_SOURCE_DRIVER:-generic-mmc} --device $W_CD --driver ${CD_WRITE_DRIVER:-generic-mmc} $CDRDAO_TMP_OPT --overburn --force"
									else
										PROG_OPT="$COPY --on-the-fly -v 2 $CDRDAO_OPT $Eject --source-device $R_CD --source-driver ${CD_SOURCE_DRIVER:-generic-mmc} --device $W_CD --driver ${CD_WRITE_DRIVER:-generic-mmc} --overburn --force"
									fi
									# ausführen
									eval $CD_PROG ${=PROG_OPT} 2>&1 | \
										progressbox "$BURN_PROGRESS_TITLE" "$COPY_CD_PROGRESS_MSG" || \
										(print ; lock -r "$DEVICES" ; prog_failure)
									# Laufwerke unlocken
									lock -r "$DEVICES"
									# Ist Anz grösser als 1 wird zum wechseln
									# des Mediums aufgefordert.
									if [ "$Anz" -gt 1 ] ; then
										# CD wechseln
										change_cddvd_msg
										# Laufwerk einfahren
										eject -t "$W_CD" &>/dev/null
										# 2 Sekunden warten
										sleep 2
									fi
									(( Anz-- ))
								done	
								# $CDRDAO_TOC und evtl. das Image löschen.
								rm -f $CDRDAO_TOC &>/dev/null
								if [[ -f ${TMP_DIR}/${VOLID// /_}.img ]] && \
									[[ $DEL_IMAGE == yes ]] ; then
									del_file -s "${TMP_DIR}/${VOLID// /_}.img"
								fi
							else
								no_data_medium_msg
							fi
							## }}}
						fi
					else
						MSG=$(gettext 'Für CD-kopieren müssen Sie ein Lese- und Schreiblaufwerk konfiguriert haben.')
						msgbox "$gv_Attention" "$MSG"
					fi
					## }}}
					;;
				dvd)
					# DVD kopieren{{{
					# Prüfen ob der Brennvorgang simuliert werden soll.
					check_simulate $DVD_PROG
					if [ "$R_DVD" -a "$W_DVD" ] ; then
						# Brennlaufwerk ausbinden
						mount_check -a $W_CD
						if [[ $U_MOUNT == no ]] ; then
							return 1
						fi
						# Brennen mit nur 1 Laufwerk. # {{{
						if [ "$R_DVD" = "$W_DVD" ] ; then
							# dvd checken ob was drauf ist
							check_dvd_state "$R_DVD"
							if [ "$DVD_IS_CAP" -gt 0 ] ; then
								# vorhandenen und benötigten DVD Platz berechnen.
								if ! check_size_to_dir "$DVD_IS_CAP" "$TMP_DIR" ; then
									return 1
								fi
								# Device locken
								lock "$R_DVD"
								# Variablenwert sichern für check_exec_dd
								Dvd_Size="$BLOCK_SIZE"
								# Mit dd(_rescue) eine temporäre Datei erstellen (1:1 Kopie).
								if ! check_exec_dd "$R_DVD" "$Dvd_Size" ; then
									lock -r "$R_DVD"
									return 1
								fi
								# Device unlocken
								lock -r "$R_DVD"
								# Nachdem erstellen des Image ist alles
								# abgeschlossen
								if [ "$CREATE_IMAGE_ONLY" = yes ] ; then
									# fertig
									unset -- $Unset
									return 0
								fi
								# Prüfen ob das Medium ausgeworfen werden soll.
								check_eject $DVD_PROG "$R_DVD"
								# wieviel Kopien brennen
								Anz=$COPYNR
								while [ "$Anz" -ge 1 ] ; do
									# DVD wechseln
									change_cddvd_msg
									# Laufwerk einfahren
									eject -t "$W_DVD" &>/dev/null
									# 2 Sekunden warten
									sleep 2
									# DVD Rohling prüfen
									if ! check_write_dvd "$W_DVD" "$Dvd_Size" ; then
										return 1
									fi
									# Device locken
									lock "$W_DVD"
									# ausführen
									PROG_OPT="$WRITE -use-the-force-luke=spare:none -speed=${DVD_SPEED} -dvd-compat -Z $W_DVD=${TMP_DIR%/}/${VOLID// /_}.img"
									eval $DVD_PROG ${=PROG_OPT} 2>&1 | \
										progressbox "$BURN_PROGRESS_TITLE" "$BURN_DVD_PROGRESS1_MSG" || \
										(print ; lock -r "$W_DVD" ; prog_failure)
									lock -r "$W_DVD"
									# Prüfen ob das Medium ausgeworfen werden soll.
									check_eject $DVD_PROG "$W_DVD"
									# Ist Anz grösser als 1 wird zum wechseln
									# des Mediums aufgefordert.
									if [ "$Anz" -gt 1 ] ; then
										# DVD wechseln
										change_cddvd_msg
										# Laufwerk einfahren
										eject -t "$W_DVD" &>/dev/null
										# 2 Sekunden warten
										sleep 2
									fi
									(( Anz-- ))
								done
								# evtl. das Image löschen.
								if [[ -f ${TMP_DIR}/${VOLID// /_}.img ]] && \
									[[ $DEL_IMAGE == yes ]] ; then
									del_file -s "${TMP_DIR}/${VOLID// /_}.img"
								fi
								unset -- $Unset
							else	
								no_data_medium_msg
								return 1
							fi
							#}}}
						else
							# Brennen mit mehreren Laufwerken.# {{{
							# dvd checken ob was drauf ist.
							check_dvd_state "$R_DVD"
							if [ "$DVD_IS_CAP" -gt 0 ] ; then
								# Variablenwerte sichern
								Dvd_Size="$BLOCK_SIZE"
								# Nachdem erstellen des Image ist alles
								# abgeschlossen
								if [ "$CREATE_IMAGE_ONLY" = yes ] ; then
									if ! check_size_to_dir "$DVD_IS_CAP" "$TMP_DIR" ; then
										return 1
									fi
									# Mit dd(_rescue) eine temporäre Datei erstellen (1:1 Kopie).
									lock $R_DVD
									if ! check_exec_dd "$R_DVD" "$Dvd_Size" ; then
										# Laufwerk unlocken
										lock -r $R_DVD
										return 1
									fi
									# Laufwerk unlocken
									lock -r $R_DVD
									# fertig
									unset -- $Unset
									return 0
								fi
								# Laufwerk einfahren
								eject -t "$W_DVD" &>/dev/null
								# 2 Sekunden warten
								sleep 2
								# Prüfen ob ein Image erstellt werden soll oder nicht.
								if [[ $CREATE_IMAGE == yes ]] ; then
									if ! check_size_to_dir "$DVD_IS_CAP" "$TMP_DIR" ; then
										return 1
									fi
									# Mit dd(_rescue) eine temporäre Datei erstellen (1:1 Kopie).
									# Laufwerk locken
									lock $R_DVD
									if ! check_exec_dd "$R_DVD" "$Dvd_Size" ; then
										# Laufwerk unlocken
										lock -r $R_DVD
										return 1
									fi
									# Laufwerk unlocken
									lock -r $R_DVD
									DEVICES="$W_DVD"
									COPY_DVD_PROGRESS_MSG="$BURN_DVD_PROGRESS1_MSG"
									PROG_OPT="$WRITE -use-the-force-luke=spare:none -speed=${DVD_SPEED} -dvd-compat -Z $W_DVD=${TMP_DIR%/}/${VOLID// /_}.img"
								else
									DEVICES="$R_DVD $W_DVD"
									# Leselaufwerk wird wie eine Datei behandelt.
									COPY_DVD_PROGRESS_MSG="$COPY_DVD_PROGRESS_MSG"
									PROG_OPT="$WRITE -use-the-force-luke=spare:none -speed=${DVD_SPEED} -dvd-compat -Z ${W_DVD}=${R_DVD}"
								fi
								# wieviel Kopien brennen
								Anz=$COPYNR
								while [ "$Anz" -ge 1 ] ; do
									# DVD Rohling prüfen
									if ! check_write_dvd "$W_DVD" "$Dvd_Size" ; then
										return 1
									fi
									# Laufwerke locken
									lock $DEVICES
									eval $DVD_PROG ${=PROG_OPT} 2>&1 | \
										progressbox "$BURN_PROGRESS_TITLE" "$COPY_DVD_PROGRESS_MSG" || \
										(print ; lock -r $DEVICES ; prog_failure)
									# Device unlocken
									lock -r $DEVICES
									# Prüfen ob das Medium ausgeworfen werden soll.
									check_eject $DVD_PROG "$W_DVD"
									# Ist Anz grösser als 1 wird zum wechseln
									# des Mediums aufgefordert.
									if [ "$Anz" -gt 1 ] ; then
										# DVD wechseln
										change_cddvd_msg
										# Laufwerk einfahren
										eject -t "$W_DVD" &>/dev/null
										# 2 Sekunden warten
										sleep 2
									fi
									(( Anz-- ))
								done
								# evtl. das Image löschen.
								if [[ -f ${TMP_DIR}/${VOLID// /_}.img ]] && \
									[[ $DEL_IMAGE == yes ]] ; then
									del_file -s "${TMP_DIR}/${VOLID// /_}.img"
								fi
								unset -- $Unset
							else
								no_data_medium_msg
								return 1
							fi
							## }}}
						fi
					else
						MSG=$(gettext 'Für DVD-kopieren müssen Sie ein Lese- und Schreiblaufwerk konfiguriert haben.')
						msgbox "$gv_Attention" "$MSG"
						return 1
					fi
					#}}}
					;;
			esac
		else
			no_para_msg $0
			return 1
		fi
		return 0
	}
	#}}}
	# Funktion (create_image), iso9660 image erstellen{{{
	#
	# Erzeugen des ISO9660 Dateisystem Image.
	#
	# usage: create_image
	#
	create_image() {
		# Grösse des Temporären Verzeichnisses überprüfen
		if ! check_size_to_dir "$ALL_FILE_SIZE" "$TMP_DIR" ; then
			unset -- $Unset
			return 1
		fi
		# Optionen für "mkisofs" einstellen
		unset -- ON_THE_FLY_OPT
		# create mkisofs filelist
		rm -f ${gv_WorkDir}/filelist.tmp &>/dev/null
		while read file ; do
			# Datei bearbeiten
			if [ -f "$file" ] ; then
				# Volid belegen mit der 1. gefundenen Datei.
				if [ -z "$VOLID" ] ; then
					VOLID="${file%.*}"
				fi
				print "${file}=${DIR}/${file}" >>${gv_WorkDir}/filelist.tmp
			# Symlink bearbeiten
			elif [ -L "$file" ] ; then
				# Volid belegen mit dem 1. gefundenen Symlink.
				if [ -z "$VOLID" ] ; then
					VOLID="${file%.*}"
				fi
				# Symlink prüfen
				check_symlink "$file"
			else
				# sort directories (a-z)
				print -ol ${file}/**/(/N) >${gv_WorkDir}/testdir
				while read Dir ; do
					# Volid belegen mit dem 1. gefundenen Verzeichnis.
					if [ -z "$VOLID" ] ; then
						VOLID="${Dir%/}"
					fi
					#
					DummyDir="`mktemp -d ${gv_WorkDir}/dummydir_XXXXXX`"
					print "${Dir}=${DummyDir}" >>${gv_WorkDir}/filelist.tmp
					# nur Dateien
			   		for i in ${Dir}*(.N) ; {
			        	print "${i}=${DIR}/${i}" >>${gv_WorkDir}/filelist.tmp
			    	}
					# nur Symlinks
			   		for i in ${Dir}*(@N) ; {
						# Symlink prüfen
						check_symlink "$i"
			    	}
				done < ${gv_WorkDir}/testdir
			fi
		done < ${gv_WorkDir}/filelist
		#
		if [[ $CREATE_IMAGE == yes ]] ; then
			# image erstellen
			eval nice -n 0 genisoimage ${=MKISOFS_OPT} -path-list ${gv_WorkDir}/filelist.tmp \
				-o ${TMP_DIR%/}/${VOLID// /_}.iso 2>&1 | \
				progressbox "$BURN_PROGRESS_TITLE" "$CREATE_ISO_MSG" || \
				(print ; prog_failure)
		# on-the-fly geht bei CDs nur mit wodim
		elif [[ $CREATE_IMAGE == no ]] ; then
			ON_THE_FLY_OPT="$MKISOFS_OPT -path-list ${gv_WorkDir}/filelist.tmp 2>&1"
		fi
		return 0
	}
	#}}}
	# Funktion (data_burn), Daten CD/DVD brennen{{{
	#
	# usage: data_burn
	#
	data_burn() {
		MSG=$(gettext 'Die Berechnung des Platzes könnte einige Zeit in Anspruch nehmen.')
		infobox "$gv_Info" "$MSG" 2
		# Es wird die Grösse der Auswahl ausgerechnet
		# Bytes der Dateien zusammen zählen
		ALL_FILE_SIZE=""
		while read i ; do
		    a=${$(du -sb "${i}")[1]}
            (( ALL_FILE_SIZE = a+ALL_FILE_SIZE ))
		done < ${gv_WorkDir}/filelist
		# 
		burn_var
		# cdrdao{{{
		if [ "$PROG" = cdrdao ] ; then
			# Brennlaufwerk ausbinden
			mount_check -a $W_CD
			if [[ $U_MOUNT == no ]] ; then
				return 1
			fi
			check_simulate $PROG
			check_eject $PROG $W_CD
			if [ "$gv_Format" = iso ] ; then
				# Brenn Medium prüfen
				if ! check_write_cd "$W_CD" "$ALL_FILE_SIZE" ; then
					cp ${gv_WorkDir}/filelist $IST_FILE
					unset -- $Unset
					return 1
				fi
				# Puefung ob Multisession CD gebrannt werden soll
				if ! check_multisession "$PROG" "$MULTISESSION" ; then
					cp ${gv_WorkDir}/filelist $IST_FILE
					unset -- $Unset
					return 1
				fi
				# cdrdao.toc schreiben
				> $CDRDAO_TOC <<< "$CD_ROM_TYPE"
				while read f ; do
					>> $CDRDAO_TOC <<<  "TRACK $DATAMODE
DATAFILE \"`pwd`/${f}\"
ZERO 00:02:00 // post-gap"
				done < ${gv_WorkDir}/filelist
				# Brenn Optionen
				PROG_OPT="$WRITE -v 2 $Eject $CDRDAO_MS_OPT --device $WRITE_DEVICE --driver ${CD_WRITE_DRIVER:-generic-mmc} --overburn --force $CDRDAO_TOC"
				# wieviel Kopien brennen
				Anz=$COPYNR
				while [ "$Anz" -ge 1 ] ; do
					if ! check_write_cd "$W_CD" "$ALL_FILE_SIZE" ; then
						cp ${gv_WorkDir}/filelist $IST_FILE
						unset -- $Unset
						return 1
					fi
					# Brenndevice sperren
					lock $W_CD
                    # ausführen
					eval $PROG $PROG_OPT 2>&1 | \
						progressbox "$BURN_PROGRESS_TITLE" "$BURN_CD_PROGRESS_MSG" || \
						(print ; lock -r $W_CD; prog_failure)
					# Brenndevice entsperren
					lock -r $W_CD
					# Ist Anz grösser als 1 wird zum wechseln
					# des Mediums aufgefordert.
					if [ "$Anz" -gt 1 ] ; then
						# CD wechseln
						change_cddvd_msg
						# Laufwerk einfahren falls draussen
						eject -t "$W_CD" &>/dev/null
						# 2 Sekunden warten
						sleep 2
					fi
					(( Anz-- ))
				done
				rm -f $CDRDAO_TOC &>/dev/null
			else
				# Brenn Medium prüfen
				if ! check_write_cd "$W_CD" "$ALL_FILE_SIZE" ; then
					cp ${gv_WorkDir}/filelist $IST_FILE
					unset -- $Unset
					return 1
				fi
				# Auf Multisession prüfen
				# MUSS vor create_image und nach check_write_cd
				if ! check_multisession "$PROG" "$MULTISESSION" ; then
					cp -a ${gv_WorkDir}/filelist "$IST_FILE"
					unset -- $Unset
					return 1
				fi
				# Image erstellen oder on the fly brennen
				if ! create_image ; then
					cp -a ${gv_WorkDir}/filelist "$IST_FILE"
					unset -- $Unset
					return 1
				fi
				# Nachdem erstellen des Image ist alles
				# abgeschlossen
				if [[ $CREATE_IMAGE_ONLY == yes ]] ; then
					# fertig
					unset -- $Unset
					return 0
				fi
				# Brennoptionen
				# prüfen, ob mit Image oder on the fly.
				if [[ -n $ON_THE_FLY_OPT ]] && [[ $CREATE_IMAGE == no ]] ; then
					# geht nur mit wodim
					# Die Variable DUMMY wird von der Funktion check_simulate
					# belegt.
					EXEC_PROG=genisoimage
					PROG_OPT="$ON_THE_FLY_OPT | wodim $DUMMY -v ${Eject#-} $WODIM_MS_OPT -tao -waiti dev=${WRITE_DEVICE} driver=mmc_cdr -overburn -force -"
				elif [[ $CREATE_IMAGE == yes ]] && [[ -f ${TMP_DIR%/}/${VOLID// /_}.iso ]] ; then
					# cdrdao.toc schreiben
					> $CDRDAO_TOC <<< "$CD_ROM_TYPE
TRACK $DATAMODE
DATAFILE \"${TMP_DIR%/}/${VOLID// /_}.iso\"
ZERO 00:02:00 // post-gap"
					EXEC_PROG=$PROG
					BURN_CD_PROGRESS_MSG="${BURN_CD_PROGRESS_MSG/./: ${VOLID// /_}.iso.}"
					PROG_OPT="$WRITE -v 2 $Eject $CDRDAO_MS_OPT --device $WRITE_DEVICE --driver ${CD_WRITE_DRIVER:-generic-mmc} --overburn --force $CDRDAO_TOC"
				else
					# Abbruch
					MSG=$(gettext 'Es sind falsche oder nicht genügend Brennoptionen eingestellt worden. Es wird hier abgebrochen.')
					msgbox "$gv_Info" "$MSG"
					return 1
				fi
				#
				# wieviel Kopien brennen
				Anz=$COPYNR
				while [ "$Anz" -ge 1 ] ; do
					if ! check_write_cd "$W_CD" "$ALL_FILE_SIZE" ; then
						cp ${gv_WorkDir}/filelist $IST_FILE
						unset -- $Unset
						return 1
					fi
					# Laufwerk locken
					lock $W_CD
                    # ausführen
					eval $EXEC_PROG ${=PROG_OPT} 2>&1 | \
						progressbox "$BURN_PROGRESS_TITLE" "$BURN_CD_PROGRESS_MSG" || \
						(print ; lock -r $W_CD ; prog_failure)
					# Laufwerk unlocken
					lock -r $W_CD
					# Ist Anz grösser als 1 wird zum wechseln
					# des Mediums aufgefordert.
					if [ "$Anz" -gt 1 ] ; then
						# CD wechseln
						change_cddvd_msg
						# Laufwerk einfahren falls draussen
						eject -t "$W_CD" &>/dev/null
						# 2 Sekunden warten
						sleep 2
					fi
					(( Anz-- ))
				done
				# rm -f $CDRDAO_TOC &>/dev/null
				if [[ -f ${TMP_DIR%/}/${VOLID// /_}.iso ]] && [[ $DEL_IMAGE == yes ]]; then
					del_file -s "${TMP_DIR%/}/${VOLID// /_}.iso"
				fi
			fi
			#}}}
		# growisofs{{{
		elif [ "$PROG" = growisofs ] ; then
			# Brennlaufwerk ausbinden
			mount_check -a $W_DVD
			if [[ $U_MOUNT == no ]] ; then
				return 1
			fi
			check_simulate $PROG
			#
			# dvd, Dateien und iso-images brennen
			#
			if [ "$gv_Format" = iso ] ; then
				# wieviel Kopien brennen
				Anz=$COPYNR
				while [ "$Anz" -ge 1 ] ; do
					# DVD Rohling prüfen
					if ! check_write_dvd $W_DVD $ALL_FILE_SIZE ; then
						cp ${gv_WorkDir}/filelist $IST_FILE
						unset -- $Unset
						return 1
					fi
					# Auf Multisession prüfen
					if ! check_multisession "$PROG" "$MULTISESSION" ; then
						MS_START=yes
						MS_FINISH=yes
					fi
					# Laufwerk locken
					lock $W_DVD
					# ISO Datei brennen
					while read f ; do
						# ISO Datei brennen
						if [[ $MS_START == yes ]] ; then
							PROG_OPT="$WRITE -use-the-force-luke=spare:none -speed=${DVD_SPEED} -dvd-compat -Z ${W_DVD}=${f}"
							BURN_DVD_PROGRESS_MSG="${BURN_DVD_PROGRESS_MSG/./: ${f}.}"
							eval $PROG ${=PROG_OPT} 2>&1 | \
								progressbox "$BURN_PROGRESS_TITLE" "$BURN_DVD_PROGRESS_MSG" || \
								(print ; lock -r $W_DVD ; prog_failure)
						else
							PROG_OPT="$WRITE -use-the-force-luke=spare:none -speed=${DVD_SPEED} -dvd-compat -M ${W_DVD}=${f}"
							BURN_DVD_PROGRESS_MSG="${BURN_DVD_PROGRESS_MSG/./: ${f}.}"
							eval $PROG ${=PROG_OPT} 2>&1 | \
								progressbox "$BURN_PROGRESS_TITLE" "$BURN_DVD_PROGRESS_MSG" || \
								(print ; lock -r $W_DVD ; prog_failure)
						fi
					done < ${gv_WorkDir}/filelist
					# To finalize the multisession DVD maintaining maximum compatibility:
					if [[ $MS_FINISH ==  yes ]] && [[ $WRITE != -dry-run ]] ; then
						case $DVD_MEDIUM in
							DVD+RW|DVD-RW|DVD-RAM|BD-RE)
								eject -t $W_DVD
								sleep 3
		            			eval $PROG -M ${W_DVD}=/dev/zero 2>&1 | \
									progressbox "$BURN_PROGRESS_TITLE" "$BURN_FINISH_PROGRESS_MSG" || \
									(print ; lock -r $W_DVD ; prog_failure)
								;;
						esac
					fi
					# Laufwerk unlocken
					lock -r $W_DVD
					# Rohling auswerfen?
					check_eject $PROG $W_DVD
					# Ist Anz grösser als 1 wird zum wechseln
					# des Mediums aufgefordert.
					if [ "$Anz" -gt 1 ] ; then
						# DVD wechseln
						change_cddvd_msg
						# Laufwerk einfahren, falls draussen
						eject -t "$W_DVD" &>/dev/null
						# 2 Sekunden warten
						sleep 2
					fi
					(( Anz-- ))
				done
			else
				# Dateien/Verzeichnis/... brennen.
				#
				# Image erstellen oder on the fly brennen
				if ! create_image ; then
					cp ${gv_WorkDir}/filelist $IST_FILE
					unset -- $Unset
					return 1
				fi
				# Nachdem erstellen des Image ist alles
				# abgeschlossen
				if [[ $CREATE_IMAGE_ONLY == yes ]] ; then
					unset -- $Unset
					return 0
				fi
				# Auf Multisession prüfen
				if ! check_multisession "$PROG" "$MULTISESSION" ; then
					MS_START=yes
					MS_FINISH=yes
				fi
				# wieviel Kopien brennen
				Anz=$COPYNR
				while [ "$Anz" -ge 1 ] ; do
					# DVD Rohling prüfen
					if ! check_write_dvd $W_DVD $ALL_FILE_SIZE ; then
						cp ${gv_WorkDir}/filelist $IST_FILE
						unset -- $Unset
						return 1
					fi
					# Laufwerk locken
					lock $W_DVD
					# brennen
					if [[ $CREATE_IMAGE == yes ]] && [[ -f ${TMP_DIR}/${VOLID// /_}.iso ]] ; then
						if [[ $MS_START == yes ]] ; then
							f=${TMP_DIR}/${VOLID// /_}.iso
							PROG_OPT="$WRITE -use-the-force-luke=spare:none -speed=${DVD_SPEED} -dvd-compat -Z ${W_DVD}=${f}"
							BURN_DVD_PROGRESS_MSG="${BURN_DVD_PROGRESS_MSG/./: ${f}.}"
							eval $PROG ${=PROG_OPT} 2>&1 | \
								progressbox "$BURN_PROGRESS_TITLE" "$BURN_DVD_PROGRESS_MSG" || \
								(print ; lock -r $W_DVD ; prog_failure)
						else
							f=${TMP_DIR}/${VOLID// /_}.iso
							PROG_OPT="$WRITE -use-the-force-luke=spare:none -speed=${DVD_SPEED} -dvd-compat -M ${W_DVD}=${f}"
							BURN_DVD_PROGRESS_MSG="${BURN_DVD_PROGRESS_MSG/./: ${f}.}"
							eval $PROG ${=PROG_OPT} 2>&1 | \
								progressbox "$BURN_PROGRESS_TITLE" "$BURN_DVD_PROGRESS_MSG" || \
								(print ; lock -r $W_DVD ; prog_failure)
						fi
					elif [[ -n $ON_THE_FLY_OPT ]] && [[ $CREATE_IMAGE == no ]] ; then
						if [[ $MS_START == yes ]] ; then
							# Initial Session
							PROG_OPT="$WRITE -use-the-force-luke=spare:none -speed=${DVD_SPEED} -dvd-compat -Z ${W_DVD} $ON_THE_FLY_OPT"
							eval $PROG ${=PROG_OPT} 2>&1 | \
								progressbox "$BURN_PROGRESS_TITLE" "$BURN_DVD_PROGRESS_MSG" || \
								(print ; lock -r $W_DVD ; prog_failure)
						else
							# Dateien hinzufügen - multisession
							PROG_OPT="$WRITE -use-the-force-luke=spare:none -speed=${DVD_SPEED} -dvd-compat -M ${W_DVD} $ON_THE_FLY_OPT"
							eval $PROG ${=PROG_OPT} 2>&1 | \
								progressbox "$BURN_PROGRESS_TITLE" "$BURN_DVD_PROGRESS_MSG" || \
								(print ; lock -r $W_DVD ; prog_failure)
						fi
					fi
					# To finalize the multisession DVD maintaining maximum compatibility:
					if [[ $MS_FINISH ==  yes ]] && [[ $WRITE != -dry-run ]] ; then
						case $DVD_MEDIUM in
							DVD+RW|DVD-RW|DVD-RAM|BD-RE)
								eject -t $W_DVD
								sleep 3
		            			eval $PROG -M ${W_DVD}=/dev/zero 2>&1 | \
									progressbox "$BURN_PROGRESS_TITLE" "$BURN_FINISH_PROGRESS_MSG" || \
									(print ; lock -r $W_DVD ; prog_failure)
								;;
						esac
					fi
					# Laufwerk unlocken
					lock -r $W_DVD
					# Rohling auswerfen?
					check_eject $PROG $W_DVD
					# Ist Anz grösser als 1 wird zum wechseln
					# des Mediums aufgefordert.
					if [ "$Anz" -gt 1 ] ; then
						# DVD wechseln
						change_cddvd_msg
						# Laufwerk einfahren, falls draussen
						eject -t "$W_DVD" &>/dev/null
						# 2 Sekunden warten
						sleep 2
					fi
					(( Anz-- ))
				done
				# Image löschen.
				if [[ $DEL_IMAGE == yes ]] && [[ -f ${TMP_DIR}/${VOLID// /_}.iso ]] ; then
					del_file -s ${TMP_DIR}/${VOLID// /_}.iso
				fi
			fi
		fi
		#}}}
		return 0
	}
	#}}}
	# Funktion (device_driver), für CD/DVD Brenner Treiber von cdrdao/wodim{{{
	#
	# usage: device_driver
	#
	device_driver() {
		DRIVER_TITLE=$(gettext 'Konfiguration::Laufwerks-Treiber')
		case "$CD_PROG" in
			cdrdao)
				DRIVER_MENU=(cdd2600 \"\" generic-mmc \"\" generic-mmc-raw \"\" plextor \"\"
				plextor-scan \"\" ricoh-mp6200 \"\" sony-cdu-920 \"\" sony-cdu-948 \"\"
				taiyo-yuden \"\" teac-cdr55 \"\" toshiba \"\" yamaha-cdr10x \"\")
				;;
			wodim)
				DRIVER_MENU=(mmc_cd \"\" mmc_cd_dvd \"\" mmc_cdr \"\" mmc_cdr_sony \"\"
				mmc_dvd \"\" mmc_dvdplus \"\" mmc_dvdplusr \"\" mmc_dvdplusrw \"\"
				cw_7501 \"\" kodak_pcd_600 \"\" philips_cdd521 \"\" philips_cdd521_old \"\"
				philips_cdd522 \"\" philips_dumb \"\" pioneer_dws114x \"\" plasmon_rf4100 \"\"
				ricoh_ro1060c \"\" ricoh_ro1420c \"\" scsi2_cd \"\" sony_cd0924 \"\"
				teac_cdr50 \"\" tyuden_ew50 \"\" yamaha_cdr100 \"\" cdr_simul \"\"
				dvd_simul \"\")
				;;
			*)
				DRIVER_MENU=($gv_Back \"\")
				;;
		esac
		menubox "$1" "$DRIVER_TITLE" "$gv_Configuration" "$DRIVER_MENU" "$DRIVER"
		while [ "$gv_Auswahl" ] ; do
			case "$gv_Auswahl" in
				HELP*)	# Hilfe für die Konfiguration des Brenner Treibers
					script_help share/cd_driver_help
					menubox "${gv_Auswahl#HELP }" "$DRIVER_TITLE" "$gv_Configuration" "$DRIVER_MENU" "$DRIVER"
					;;
				$gv_Back)
					break
					;;
				*)	#
					DRIVER="$gv_Auswahl"
					break
					;;
			esac
		done
	}
	#}}}
	# Funktion (image_burn), image brennen{{{
	#
	# usage: image_burn
	#
	image_burn() {
		#
		# Verzeichnis auswählen in dem die zu brennenden 
		# Dateien/Verzeichnisse liegen.
		#
		if [ -z "$DIR" ] ; then
			if [ "$gv_Format" = Video-CD -o "$gv_Format" = Video-DVD ] ; then
				read_file kwvcdburnrc
				DIR="$FILM_DIR"
			elif [ "$gv_Format" = mp3 -o "$gv_Format" = wav -o "$gv_Format" = ogg ] ; then
				read_file kwsnd2sndfmrc
				DIR="$SND_DIR"
			fi
		fi
		if [ -z "$DIR" ] ; then
			DIR="$(pwd)"
		fi
		#
		dselect "$DIR"
		if [ -n "$VERZ" ] ; then
			dselect_check "$VERZ"
			if [ -n "$VERZ" ] ; then
				DIR="$VERZ"
				cd "$VERZ"
				#
				case "$gv_Format" in
					iso)
						# ISO Images brennen# {{{
						file_filter "$FORMAT" "$SUFFIX"
						if [ "${DF_ARRAY[1]}" ] ; then
							checklist "" "$BURN_PROGRESS_TITLE" "$FILE_CHOICE_MSG" "$DF_ARRAY"
							while [ "$gv_Auswahl" ] ; do
								case "$gv_Auswahl" in
									HELP*)	#
										script_help share/data_help
										checklist "${gv_Auswahl#HELP }" "$BURN_PROGRESS_TITLE" "$FILE_CHOICE_MSG" "$DF_ARRAY"
										;;
									*)	
										# Dateien von $gv_LogFile$$ nach ${gv_WorkDir}/filelist verschieben
										if ! mv $gv_LogFile$$ ${gv_WorkDir}/filelist ; then
											return 1
										fi
										# mkisofs Optionen
										if ! burn_opt ; then
											unset -- $Unset
											return 1
										fi
										# Dateien zum brennen sind in der Datei ${gv_WorkDir}/filelist.
										if ! data_burn ; then
											unset -- $Unset
											return 1
										fi
										#
										file_filter "$FORMAT" "$SUFFIX"
										checklist "" "$BURN_PROGRESS_TITLE" "$FILE_CHOICE_MSG" "$DF_ARRAY"
										;;
								esac
							done
						else
							no_file_msg "${FORMAT#\^}"
						fi
						## }}}
						;;
					Video-CD)
						# Video-CD brennen# {{{
						file_filter "$FORMAT" "$SUFFIX"
						if [ "${DF_ARRAY[1]}" ] ; then
							# Film Images haben meist die Grösse einer CD, so das hier nur 1
							# Datei zur Zeit zur Verfügung gestellt wird.
							#
							VCD_MSG=$(gettext 'Wählen Sie einen Film aus.')
							radiolist "" "$BURN_PROGRESS_TITLE" "$VCD_MSG" "$DF_ARRAY"
							while [ "$gv_Auswahl" ] ; do
								case "$gv_Auswahl" in
									HELP*)	
										# Hilfe
										script_help share/data_help
										radiolist "${gv_Auswahl#HELP }" "$BURN_PROGRESS_TITLE" "$VCD_MSG" "$DF_ARRAY"
										;;
									*)	# Auswahl übernehmen
										VCD_FILE="$gv_Auswahl"
										ALL_FILE_SIZE=${$(du -sb "$VCD_FILE")[1]}
										#
										# mkisofs Optionen
										if ! burn_opt ; then
											unset -- $Unset
											return 1
										fi
										burn_var
										# Brennlaufwerk ausbinden
										mount_check -a $W_CD
										if [[ $U_MOUNT == no ]] ; then
											return 1
										fi
										# cdrdao Brennoption
										check_simulate "$PROG"
										check_eject "$PROG" "$W_CD"
										#
										# wieviel Kopien brennen
										Anz=$COPYNR
										while [ "$Anz" -ge 1 ] ; do
											# Laufwerk einfahren, falls draussen.
											eject -t "$W_CD" &>/dev/null
											# 2 Sekunden warten
											sleep 2
											# CD Rohling prüfen
											if ! check_write_cd "$W_CD" "$ALL_FILE_SIZE" ; then
												return 1
											fi
											# Device locken
											lock $W_CD
											# ausführen
											PROG_OPT="$WRITE -v 2 $Eject --device $W_CD --driver ${CD_WRITE_DRIVER:-generic-mmc} --overburn --force $VCD_FILE"
											eval $PROG ${=PROG_OPT} 2>&1 | \
												progressbox "$BURN_PROGRESS_TITLE" "$BURN_CD_PROGRESS_MSG" || \
												(print ; lock -r $W_CD ; prog_failure)
											lock -r $W_CD
											if [ "$Anz" -gt 1 ] ; then
												# CD wechseln
												change_cddvd_msg
												# Laufwerk einfahren
												eject -t "$W_CD" &>/dev/null
												# 2 Sekunden warten
												sleep 2
											fi
											(( Anz-- ))
										done
										# fertig
										break
										;;
								esac
							done
						else
							no_file_msg "$FORMAT"
						fi
						## }}}
						;;
					Video-DVD)
						# Video-DVD brennen# {{{
						# DVD Verzeichnis prüfen
						if [ -f ./VIDEO_TS/VIDEO_TS.IFO ] ; then
							# mkisofs Optionen
							if ! burn_opt ; then
								unset -- $Unset
								return 1
							fi
							burn_var
							# Brennlaufwerk ausbinden
							mount_check -a $W_DVD
							if [[ $U_MOUNT == no ]] ; then
								return 1
							fi
							check_simulate "$PROG"
							# Laufwerk einfahren, falls draussen.
							eject -t "$W_DVD" &>/dev/null
							# 2 Sekunden warten
							sleep 2
							# Grösse berechnen
							ALL_FILE_SIZE=${$(du -sb ./)[1]}
							# Image erstellen
							if [[ $CREATE_IMAGE == yes ]] ; then
								# vorhandenen und benötigten DVD Platz berechnen.
								if ! check_size_to_dir "$ALL_FILE_SIZE" "$TMP_DIR" ; then
									unset -- $Unset
									return 1
								fi
								# ausführen
								eval nice -n 0 genisoimage ${=MKISOFS_OPT} -udf -dvd-video \
									-o ${TMP_DIR%/}/${VOLID// /_}.iso ./ 2>&1 | \
									progressbox "$ISO_TITLE" "$CREATE_ISO_MSG" || \
									(print ; prog_failure)
							fi
							# Nachdem erstellen des Image ist alles
							# abgeschlossen
							if [[ $CREATE_IMAGE_ONLY == yes ]] ; then
								# fertig
								unset -- $Unset
								return 0
							fi
							# Auf on the fly prüfen und Brennoptionen belegen.
							if [[ $CREATE_IMAGE == yes ]] && [[ -f ${TMP_DIR%/}/${VOLID// /_}.iso ]] ; then
								BURN_DVD_PROGRESS_MSG="${BURN_DVD_PROGRESS_MSG/./: ${VOLID// /_}.iso.}"
								PROG_OPT="$WRITE -use-the-force-luke=spare:none -speed=${DVD_SPEED} -dvd-compat -Z ${W_DVD}=${TMP_DIR%/}/${VOLID// /_}.iso"
							else
								PROG_OPT="$WRITE -use-the-force-luke=spare:none -speed=${DVD_SPEED} -dvd-compat -Z ${W_DVD} $MKISOFS_OPT -udf -dvd-video ./"
							fi
							# wieviel Kopien brennen
							Anz=$COPYNR
							while [ "$Anz" -ge 1 ] ; do
								# DVD Rohling prüfen
								if ! check_write_dvd "$W_DVD" "$ALL_FILE_SIZE" ; then
									unset -- $Unset
									return 1
								fi
								# Laufwerk locken
								lock $W_DVD
								# brennen
								eval $PROG ${=PROG_OPT} 2>&1 | \
									progressbox "$BURN_PROGRESS_TITLE" "$BURN_DVD_PROGRESS_MSG" || \
									(print ; lock -r $W_DVD ; prog_failure)
								# Laufwerk unlocken
								lock -r $W_DVD
								# DVD rauswerfen
								check_eject $PROG $W_DVD
								# Ist Anz grösser als 1 wird zum wechseln
								# des Mediums aufgefordert.
								if [ "$Anz" -gt 1 ] ; then
									# DVD wechseln
									change_cddvd_msg
									# Laufwerk einfahren
									eject -t "$W_DVD" &>/dev/null
									# 2 Sekunden warten
									sleep 2
								fi
								(( Anz-- ))
							done
							# Image löschen
							if [[ -f ${TMP_DIR%/}/${VOLID// /_}.iso ]] && [[ $DEL_IMAGE == yes ]] ; then
	                            del_file -s ${TMP_DIR%/}/${VOLID// /_}.iso
	                        fi
							unset -- $Unset
						else
							MSG=$(gettext 'Es gibt keine Inhalts Tabelle für diese DVD oder Sie sind im falschen Verzeichnis ($VERZ).')
							msgbox "$gv_Attention" "$MSG"
							unset -- $Unset
							return 1
						fi
						## }}}
						;;
					mp3 | ogg | photo)
						# ausgewählte ogg | mp3 | photo Dateien brennen# {{{
						# nur im lokalen Verzeichnis suchen.
						file_filter "$FORMAT" "$SUFFIX"
						if [ "${DF_ARRAY[1]}" ] ; then
							checklist "" "$BURN_PROGRESS_TITLE" "$FILE_CHOICE_MSG" "$DF_ARRAY"
							while [ "$gv_Auswahl" ] ; do
								case "$gv_Auswahl" in
									HELP*)	#
										script_help share/data_help
										checklist "${gv_Auswahl#HELP }" "$BURN_PROGRESS_TITLE" "$FILE_CHOICE_MSG" "$DF_ARRAY"
										;;
									*)
										# Dateien von $gv_LogFile$$ nach ${gv_WorkDir}/filelist verschieben
										if ! mv $gv_LogFile$$ ${gv_WorkDir}/filelist ; then
											return 1
										fi
										# mkisofs Optionen
										if ! burn_opt ; then
											unset -- $Unset
											return 1
										fi
										# Dateien zum brennen sind in der Datei ${gv_WorkDir}/filelist.
										if ! data_burn ; then
											unset -- $Unset
											return 1
										fi
										#
										file_filter "$FORMAT" "$SUFFIX"
										checklist "" "$BURN_PROGRESS_TITLE" "$FILE_CHOICE_MSG" "$DF_ARRAY"
										;;
								esac
							done
						else
							no_file_msg "$FORMAT"
						fi
						## }}}
						;;
					wav)
						# ausgewählte wav Dateien brennen# {{{
						file_filter "$FORMAT" "$SUFFIX"
						if [ "${DF_ARRAY[1]}" ] ; then
							checklist "" "$BURN_PROGRESS_TITLE" "$FILE_CHOICE_MSG" "$DF_ARRAY"
							while [ "$gv_Auswahl" ] ; do
								case "$gv_Auswahl" in
									HELP*)
										script_help share/data_help
										checklist "${gv_Auswahl#HELP }" "$BURN_PROGRESS_TITLE" "$FILE_CHOICE_MSG" "$DF_ARRAY"
										;;
									*)	#
										# Dateien von $gv_LogFile$$ nach ${gv_WorkDir}/filelist verschieben
										if ! mv $gv_LogFile$$ ${gv_WorkDir}/filelist ; then
											return 1
										fi
										case "$PROG" in
											cdrdao)
												# cdrdao{{{
												# erst einmal die TOC-Datei löschen
												rm -f $CDRDAO_TOC &>/dev/null
												# mkisofs Optionen
												if ! burn_opt ; then
													unset -- $Unset
													break 2
												fi
												burn_var
												# Brennlaufwerk ausbinden
												mount_check -a $W_CD
												if [[ $U_MOUNT == no ]] ; then
													return 1
												fi
												# Grösse berechnen
												ALL_FILE_SIZE=""
												while read i ; do
													a=${$(du -sb "$i")[1]}
													(( ALL_FILE_SIZE = a+ALL_FILE_SIZE ))
												done < ${gv_WorkDir}/filelist
												# CD Rohling prüfen
												if ! check_write_cd "$W_CD" "$ALL_FILE_SIZE" ; then
													cp ${gv_WorkDir}/filelist "$IST_FILE"
													unset -- $Unset
													break 2
												fi
												# Puefung ob Multisession CD gebrannt werden soll
												if ! check_multisession "$PROG" "$MULTISESSION" ; then
													break 2
												fi
												#
												# Es werden normale Audio CD's gebrannt mit 2 Sekunden Pause
												# zwischen den Titeln gebrannt.
												#
												case "$CD_ROM_TYPE" in
													CD_DA)
														> $CDRDAO_TOC <<< "$CD_ROM_TYPE" 
														while read i ; do
														>> $CDRDAO_TOC <<< "TRACK $DATAMODE
SILENCE 00:02:00 // pre-gap
AUDIOFILE \"`pwd`/${i}\" 0"
														done < ${gv_WorkDir}/filelist
														;;
													*)
														> $CDRDAO_TOC <<< "$CD_ROM_TYPE" 
														while read i ; do
														>> $CDRDAO_TOC <<< "TRACK $DATAMODE
DATAFILE \"`pwd`/${i}\" 0
ZERO 00:02:00 // post-gap"
														done < ${gv_WorkDir}/filelist
														;;
												esac
												# Laufwerk einfahren
												eject -t $W_CD &>/dev/null
												# 2 Sekunden warten
												sleep 2
												#
												# Brennoptionen
												check_simulate $PROG
												check_eject $PROG $W_CD
												PROG_OPT="$WRITE -v 2 $Eject $CDRDAO_MS_OPT --device $W_CD --driver ${CD_WRITE_DRIVER:-generic-mmc} --overburn --force $CDRDAO_TOC"
												# ausführen
												# wieviel Kopien brennen
												Anz=$COPYNR
												while [ "$Anz" -ge 1 ] ; do
													# CD Rohling prüfen
													if ! check_write_cd "$W_CD" "$ALL_FILE_SIZE" ; then
														cp ${gv_WorkDir}/filelist "$IST_FILE"
														unset -- $Unset
														break 2
													fi
													# Laufwerk locken
													lock $W_CD
                                                    # ausführen
													eval $PROG ${=PROG_OPT} 2>&1 | \
														progressbox "$BURN_PROGRESS_TITLE" "$BURN_CD_PROGRESS_MSG" || \
														(print ; lock -r $W_CD ; prog_failure)
													# Laufwerk unlocken
													lock -r $W_CD
													# Ist Anz grösser als 1 wird zum wechseln
													# des Mediums aufgefordert.
													if [ "$Anz" -gt 1 ] ; then
														# CD wechseln
														change_cddvd_msg
														# Laufwerk einfahren
														eject -t "$W_CD" &>/dev/null
														# 2 Sekunden warten
													fi
												 	(( Anz-- ))
												done
												# TOC Datei löschen
												rm -f $CDRDAO_TOC &>/dev/null
												unset -- $Unset
												break 2
												#}}}
												;;
											growisofs)
												# growisofs# {{{
												# mkisofs Optionen
												if ! burn_opt ; then
													unset -- $Unset
													break 2
												fi
												# Dateien zum brennen sind in der Datei 
												# ${gv_WorkDir}/filelist.
												if ! data_burn ; then
													unset -- $Unset
													break 2
												fi
												break 2
												## }}}
												;;
										esac
									;;
								esac
							done
						else
							no_file_msg "$FORMAT"
						fi
						## }}}
						;;
					*)
						# alle Dateien und Verzeichnisse zur Auswahl anbieten# {{{
						unset -- DF_ARRAY
						Anz=0
						for i in * ; {
							if [ -d "$i" ] ; then
								(( Anz++ ))
								if [ -f "$IST_FILE" ] ; then
									IST=`print ${(M)${(f)"$(< $IST_FILE)"}##*"${i}"*}`
									if [ "$IST" ] ; then
										DF_ARRAY[Anz]="${(qq)i} \"$VERZEICHNIS\" on"
									else
										DF_ARRAY[Anz]="${(qq)i} \"$VERZEICHNIS\" off"
									fi
								else
									DF_ARRAY[Anz]="${(qq)i} \"$VERZEICHNIS\" off"
								fi
							elif [ -f "$i" ] ; then
								(( Anz++ ))
								if [ -f "$IST_FILE" ] ; then
									IST=`print ${(M)${(f)"$(< $IST_FILE)"}##*"${i}"*}`
									if [ "$IST" ] ; then
										DF_ARRAY[Anz]="${(qq)i} \"$DATEI\" on"
									else
										DF_ARRAY[Anz]="${(qq)i} \"$DATEI\" off"
									fi
								else
									DF_ARRAY[Anz]="${(qq)i} \"$DATEI\" off"
								fi
							elif [ -L "$i" ] ; then
								(( Anz++ ))
								if [ -f "$IST_FILE" ] ; then
									IST=`print ${(M)${(f)"$(< $IST_FILE)"}##*"${i}"*}`
									if [ "$IST" ] ; then
										DF_ARRAY[Anz]="${(qq)i} \"$DATEI\" on"
									else
										DF_ARRAY[Anz]="${(qq)i} \"$DATEI\" off"
									fi
								else
									DF_ARRAY[Anz]="${(qq)i} \"$DATEI\" off"
								fi
							fi
						}
						#
						if [ "${DF_ARRAY[1]}" ] ; then
							checklist "" "$BURN_PROGRESS_TITLE" "$FILE_CHOICE_MSG" "$DF_ARRAY"
							while [ "$gv_Auswahl" ] ; do
								case "$gv_Auswahl" in
									HELP*)	
										# Hilfe
										script_help share/data_help
										checklist "${gv_Auswahl#HELP }" "$BURN_PROGRESS_TITLE" "$FILE_CHOICE_MSG" "$DF_ARRAY"
										;;
									*)	
										# Dateien von $gv_LogFile$$ nach ${gv_WorkDir}/filelist verschieben
										if ! mv $gv_LogFile$$ ${gv_WorkDir}/filelist ; then
											return 1
										fi
										# mkisofs Optionen
										if ! burn_opt ; then
											unset -- $Unset
											return 1
										fi
										# Daten brennen, diese befinden sich in der Datei
										# ${gv_WorkDir}/filelist.
										if ! data_burn ; then
											unset -- $Unset
											return 1
										fi
										# ferig
										return 0
										;;
								esac
							done
						else
							no_file_msg "*"
						fi
					## }}}
						;;
				esac
			fi
		fi
		return 0
	}
	#}}}
# Funktion (split_size), für Datei Grösse ab der{{{
# die Datei gesplittet werden soll.
#
# usage: split_size
#
split_size() {
	C_Menue=(650 \"Mbyte\" 680 \"Mbyte\" 700 \"Mbyte\" 800 \"Mbyte\"
		1000 \"Mbyte\" 2000 \"Mbyte\" 4000 \"Mbyte\" 64000 \"Mbyte\")
	SPLIT_SIZE_TITLE=$(gettext 'Konfiguration::Dateigrösse')
	menubox "$SPLIT_SIZE" "$SPLIT_SIZE_TITLE" "$gv_Menupoint" "$C_Menue"
	while [ "$gv_Auswahl" ] ; do
		case "$gv_Auswahl" in
			HELP*)	# Hilfe für die Konfiguration der Datei Grösse
				script_help share/split_size_help
				menubox "${gv_Auswahl#HELP }" "$SPLIT_SIZE_TITLE" "$gv_Menupoint" "$C_Menue"
				;;
			*)	#
				SPLIT_SIZE="$gv_Auswahl"
				break
				;;
		esac
	done
}
#}}}
## }}}
	###### Multimedia Nachrichten ###### {{{
	# Funktion (change_cddvd_msg), Medium wechseln, neuen Rohling einlegen# {{{
	#
	change_cddvd_msg() {
		MSG=$(gettext 'Legen Sie nun einen neuen leeren Rohling in Ihr Brennlaufwerk.')
		msgbox "$gv_Info" "$MSG"
	}
	## }}}
	# Funktion (no_burn_device_msg), kein Brenn-Laufwerk ausgewahlt# {{{
	no_burn_device_msg() {
		MSG=$(gettext 'Sie müssen ein Brennlaufwerk auswählen. Es wird abgebrochen.')
		msgbox "$gv_Attention" "$MSG"
	}
	## }}}
	# function (no_cddvd_prog_msg), kein Brennprogramm konfiguriert{{{
	# Wird vom Script kwrecord benötigt.
	#
	# usage: no_cddvd_prog_msg
	#
	no_cddvd_prog_msg() {
		MSG=$(gettext 'Sie müssen erst ein Brennprogramm (CD/DVD/BD) mit kwrecord konfigurieren. Es werden zur Zeit nur cdrdao und growisofs unterstützt.')
		msgbox "$gv_Attention" "$MSG"
	}
	#}}}
	# Funktion (no_data_medium_msg), Rohling ist leer# {{{
	no_data_medium_msg() {
		MSG=$(gettext 'Sie müssen ein Medium mit Daten einlegen.')
		msgbox "$gv_Attention" "$MSG"
	}
	## }}}
	# Funktion (over_cd_size_msg), Fehlernachricht wenn die Auswahl die CD{{{
	# Grösse übersteigt.
	#
	# usage: over_cd_size_msg CHOICE_SIZE MEDIUM_SIZE
	# CHOICE_SIZE - Ausgewählte Grösse der Dateien/Verzeichnissen in Byte.
	# MEDIUM_SIZE - Grösse des Medium in Byte
	#
	over_cd_size_msg() {
		if [[ ${#argv} == 2 ]] ; then
			unset -- Size Size1
			local Size Size1
			Size=$1
			Size1=$2
			convert_over_size $Size $Size1
	   		MSG=$(gettext 'Die Grösse der Auswahl ($DATA_SIZE) überschreitet die Grösse ($IS_SIZE) der CD-+R(W).')
			msgbox "$gv_Attention" "$MSG"
		else
			no_para_msg $0
		fi
	}
	#}}}
	# Funktion (over_dvd_size_msg), Fehlernachricht wenn die Auswahl die DVD{{{
	# Grösse übersteigt.
	#
	# usage: over_dvd_size_msg CHOICE_SIZE MEDIUM_SIZE
	# CHOICE_SIZE - Ausgewählte Grösse der Dateien/Verzeichnissen in Byte.
	# MEDIUM_SIZE - Grösse des Medium in Byte
	#
	over_dvd_size_msg() {
		if [[ ${#argv} == 2 ]] ; then
			unset -- Size Size1
			local Size Size1
			Size=$1
			Size1=$2
			convert_over_size $Size $Size1
			MSG=$(gettext 'Die Grösse der Auswahl ($DATA_SIZE) überschreitet die Grösse ($IS_SIZE) der DVD-+R(W)/RAM/BD-R(E). Es wird abgebrochen.')
			msgbox "$gv_Info" "$MSG"
		else
			no_para_msg $0
		fi
	}
	#}}}
	# Funktion (over_tmp_size_msg), Fehlernachricht wenn die Auswahl{{{
	# die Grösse des Tmp Dirs übersteigt.
	#
	# usage: over_tmp_size_msg CHOICE_SIZE TMP_SIZE
	# CHOICE_SIZE - Ausgewählte Grösse der Dateien/Verzeichnissen in Byte.
	# TMP_SIZE - Grösse des temporären Verzeichnis in Byte.
	#
	over_tmp_size_msg() {
		if [[ ${#argv} == 2 ]] ; then
			unset -- Size Size1
			local Size Size1
			Size=$1
			Size1=$2
			convert_over_size $Size $Size1
		    MSG=$(gettext 'Die Grösse der Auswahl ($DATA_SIZE) überschreitet die Grösse ($IS_SIZE) des temporären Verzeichnisses.')
			msgbox "$gv_Attention" "$MSG"
		else
			no_para_msg $0
		fi
	}
	#}}}
## }}}
}
# }}}
### Modeline {{{
### vim:ft=zsh:foldmethod=marker
### vim:set ts=4:                                                                               
### }}}
